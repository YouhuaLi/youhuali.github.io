---
layout: post
title: "“随机”不是“胡来”（2）--随机数的生成（讲稿）"
date: 2018-07-14 02:34:13.000000000 -07:00
type: post
parent_id: '0'
published: true
password: ''
key: page.1scrQvGo
status: publish
categories: []
tags: []
meta:
  _wpcom_is_markdown: '1'
  timeline_notification: '1531535657'
  _rest_api_published: '1'
  _rest_api_client_id: "-1"
  _publicize_job_id: '19987864324'
author:
  login: webcraft2013
  email: webcraft@gmail.com
  display_name: webcraft2013
  first_name: ''
  last_name: ''
---
<p>大家好，我是大老李。这期继续上期话题，聊聊随机数。上期讲了随机数的检验，这次讲讲随机数的生成和算法，这是一个比上一期更大的话题。</p>
<p>你可能听说过计算机里的随机数生成算法叫“伪随机数生成算法”，又叫“决定式随机位生成器”（<b>deterministic random bit generator</b> (<b>DRBG</b>)），意思就是它能随机生成1个二级制位，0或者1，而且是50%概率。为什么这种算法都是二进位的生成器？因为平时我们使用均匀分布随机数的场合是最多的，有了均匀分布的随机数，转换成其他分布也是比较简单的。而计算机内部又都是二进位，我有了产生0和1的二进位生成器，如果一个计算机内部浮点数是小数点后有32位，那我就可以产生32位随机二进位，作为0之后的32位小数位，这样我可以产生0-1之间的均匀分布的浮点数，供用户使用。</p>
<p>那为什么又叫“伪随机数生成算法”？为什么加一个“伪”字？很自然就是因为它达不到上一期讲过的“真随机数“的要求，目前计算机架构下也永远不可能有”真“随机数生成算法。但好在实际运用中我们不需要那么高的要求，在实际使用中，我们只要保证根据相当长历史随机数，你无法用当代主流的计算能力，在相当长的时间内，对我之后随机数的猜测的成功或失败概率，与½之间，无法产生任何“显著”的区别，或者用一个术语，就是差别是“可忽略的”（neglectable），就是你猜我随机数的成功失败概率与瞎猜之间的区别是可忽略的，那我就是很放心的。</p>
<p>具体来看伪随机数算法主要“伪”在它是有周期的，就是这个算法在输出到非常多的随机数之后，你会发现它又开始之前的模式了，开始重复自己了。只是这个周期是非常大的，我们不可能在一个软件的运行寿命内观察到这周期的发生。</p>
<p>但也因为有周期，我们不能让算法总是从固定的位置开始产生随机位，否则每次随机数重新产生都是从一样的数字开始，这是不行的。所以就需要一个所谓的“种子数”, 英文叫seed，去决定从周期中的哪个位置开始产生随机数。这一点对编程的人来说太熟悉不过了，第一次编程的人都会发现如果没有初始化“种子”，系统的随机函数总是返回同样的数。这里有个小尴尬就是为了产生随机数，我们先需要一个随机数作为“种子”。对不严格场合，我们经常会使用当前系统时间的毫秒数作为种子数，但在一些对安全性要求很高的场合，人们还会使用更复杂的方法产生这个seed，之后会聊到。</p>
<p>很惊奇的是，计算机发明开始至今，很长时间里人们所使用的随机数生成算法是很粗糙的。比如计算机刚发明的1940年代，冯诺依曼就想了一个所谓“平方取中”法，来产生随机数。取一个四位数，比如1234作为种子，算一下它的平方是1522756，在左边填充1个0，变01522756，然后他把中间四个数字输出作为随机数，就是5227。然后对5227再求平方取中间四位重复操作下去。这个算法你一听就有问题啊，我看到上一个数字就非常简单知道下一个输出是多少，都不用管你的种子数，怎么能叫随机数呢？但是冯诺依曼觉得这种随机数已经符合他的需求了，速度快，需要的资源也少，而且有可重复性，便于排错。如果使用其他硬件设备产生随机数，比如打孔纸带机作输入，那速度太慢了，消耗的资源也太大。那时，冯诺依曼也指出，如果用过于复杂的数学来产生所谓“随机数”，那可能隐藏的错误比解决的问题还多。</p>
<p><img class=" size-full wp-image-985 aligncenter" src="https://dalaoliblog.files.wordpress.com/2018/07/fennuoyiman.jpg" alt="fennuoyiman.jpg" width="292" height="172" /></p>
<p style="text-align:center;">（上图：冯诺依曼与早期计算机）</p>
<p>但显然冯诺依曼这种算法是不能满足很多场合的随机数需要的，从1960年代，人们开始普遍采用一种叫“线性同余法“，简称LCG算法来产生随机数。这个线性同余算法是非常简单的，就是考虑这么一个函数$latex ax+b \bmod c$，把余数作为随机数，然后下一个随机数就是把上一个余数作为x，迭代计算下一个余数。甚至于b可以取0，就是ax除以c求余数就可以了。各位可以自行做个简单实验，比如a=2, c=9，分别取1，2，3作为种子数，也就是第一个x，你迭代计算下2x除以9的余数，看看是不是像随机数。实际使用时，可以把每个余数转化成二进制数，依次输出。</p>
<p>LCG算法的递推公式：</p>
<p>$latex X_{n+1}=\left(aX_{n}+c\right)~~{\bmod {~}}~m$</p>
<p>我之后也会在公众号里推送这期节目讲稿时，附带一个线性同余随机数的python语言的代码以及一些简单测试，随机数生成函数体简单到只有2行。（这个代码我是取自国外知名数学博客博主John D. Cook，感谢他）。</p>
<p><code>from math import sqrt, log</code><br />
<code># Linear congruence generator (LCG) constants</code><br />
<code>z = 20170705 # seed</code><br />
<code>a = 742938285 # multiplier</code><br />
<code>e = 31 # will need this later</code><br />
<code>m = 2**e -1 # modulus</code><br />
<code># Number of random numbers to generate</code><br />
<code>N = 50</code></p>
<p><code># Format to print bits, padding with 0's on the left if needed</code><br />
<code>formatstr = "0" + str(e) + "b"</code></p>
<p><code>bit_string = ""</code><br />
<code>for _ in range(N):</code><br />
<code>    z = a*z % m # LCG</code><br />
<code>    bit_string += format(z, formatstr)</code><br />
<code>def count_ones(string):</code><br />
<code>    ones = 0</code><br />
<code>    for i in range(len(string)):</code><br />
<code>        if string[i] == '1':</code><br />
<code>        ones += 1</code><br />
<code>    return ones</code></p>
<p><code>def runs(string):</code><br />
<code>max_run = 0</code><br />
<code>    current_run = 0</code><br />
<code>    for i in range(len(string)):</code><br />
<code>       if string[i] == '1':</code><br />
<code>           current_run += 1</code><br />
<code>    else:</code><br />
<code>        current_run = 0</code><br />
<code>    max_run = max(max_run, current_run)</code><br />
<code>    return max_run</code><br />
<code>print (bit_string)</code><br />
<code>ones = count_ones(bit_string)</code><br />
<code>expected = e*N/2</code><br />
<code>sd = sqrt(0.25*N)</code><br />
<code>print( "Number of 1's: {}".format(ones) )</code><br />
<code>print( "Expected: {} to {}".format(expected - 2*sd, expected + 2*sd) )</code></p>
<p>以上这个算法的优点是很明显的，就是简单，高效。而且只要把那个被除的C搞的足够大，我就可以把周期也搞得非常长，而且能通过上期讲过的几乎所有统计学测试。所以该算法一出现就广被使用，以至于至今Java语言标准库里的Random函数，仍然是用的LCG算法，里面的被除数c是$2^{48}$，因为计算机里如果除以2幂次的计算是最快的，只要移位就可以了。a是一个奇怪的数字25214903917，b=11。然后每次不是把余数都输出，而是倒过来输出第47位到第16位，因为更高位的数字循环周期会短，所以只输出低位可以更好的通过统计学测试。</p>
<p>以上这个算法从1960年代用到现在，那足见其优越性。但它必然也有些缺点。一个是你的a,b,c三个参数必须小心选择，选的不好，就会出问题。一个著名例子是，1960年代IBM所使用的一个LCG算法叫RANDU，它是用$latex 65539\times x\bmod 2^{31}$，听上去这几个数字没啥特别不好，输出看上去也很正常。但是1963年，有人发现通过简单运算，发现它连续迭代的三项余数之间是有一个简单的减法关系，就是当前项与之前的两项有个线性关系。这使得这个算法在统计学上是完全失败了。虽然IBM在后来的机器中修正了参数，但是很多人要么不知情，要么不在意，继续使用这一算法。因为以前没网络，软件打补丁也很麻烦嘛。后果就是70年代里很多使用这个算法产生的研究结果都被认为不可靠的。据推测RANDU算法要到90年代早期才真正被废弃。这个RANDU算法就是历史上著名的一个貌似产生随机数，其实很不靠谱的典型例子。这也告诉我们一个随机数算法能不能用，不是靠眼睛看看就可以过关的，你需要很专业的软件对其测试。</p>
<p>另外要注意，在需要严格加密的场合是不能使用LCG算法的，因为如果有人愿意，他是可以从你历史输出里去反算你的种子数的。这相当于一个算术题就是：已知a, b, c和ax+b除以c的余数，请你算一下x。你是可以写一个多项式时间算法的去求解这个问题的。所以你不能使用LCG算法在需要加密的场合，而是要使用后面会提到的所谓“密码学安全”算法。</p>
<p>我们还是再简单说一个LCG算法之后的发展。在1997年，两位日本研究者发明了一个名为“梅森旋转算法”的随机数生成方法。这里的“梅森”，是取自梅森素数（如果$2^{n}-1$是一个素数，它就被称为梅森素数）的意思，因为它的周期就是一个很大的梅森素数。大老李在很早的节目里就介绍过梅森素数，它号称“数字中的宝石”。你看它现在不但是宝石而且还有了实用价值。这个算法比LCG算法的优点在于周期非常长，就是一个大的梅森素数。统计学指标上质量比LCG更优。所以它现在被广泛用语主流的一些操作系统和编程语言，包括Excel，GNU库，php, python和Ruby等等。但同样注意它是密码学不安全的，只要有人拿到足够的输出，还是可以计算出你所使用的种子数的。</p>
<p>再说说所谓“密码学安全”的随机数生成算法。首先我们得给“密码学安全”一个定义，什么叫“密码学安全”。我们看到前面的算法“不安全”，其不安全就在于我们可以通过观察历史数据，来推测出你所使用的种子数，最终达到预测之后所产生的随机数的效果。那反过来也就是，一个密码学安全的随机数算法，要做到我给你相当长的历史数据，你也有非常强的电脑，我仍然可以确保你不能在充分长的时间，比如1年内，对我将来的产生的随机数的猜测，产生任何“不可忽略”的变化。这里的“相当长”，“非常强”，“充分长”，“不可忽略”，都是一些变量，我们不需要对这些变量有精确的数字定义，只要知道这些变量是可以用来衡量最终算法质量的。在不同场合，我们可以给这些变量定义一些值，如果算法能达到我们定义的这些值，那么这么算法就可以被用在我们的这个场合下。</p>
<p>而数学家用的一个高招就是把破解算法的难度与破解一个数学难题等价起来。也就是如果你能破解这个算法，就等于你破解了一个数学上非常难的问题。那你能破解这个数学问题，你就能拿菲尔兹奖，你也犯不着去破解算法吧。当然，也可能有人能破解这些算法了，但是他秘而不宣，利用这能力谋取利益，或者达到一些自己的目的。比如《达芬奇密码》这部小说的作者丹布朗的另一部小说《数字城堡》，其背景就是说美国政府秘密造出一台超级计算机和一个秘密算法，使得他们可以解密目前网上主流加密算法加密过的信息，这样美国政府就可以监控很多网上的秘密通信了。当然，这只是小说的设定，目前没有什么证据能证明有人掌握了某种超级解密算法。</p>
<p><img class=" size-full wp-image-986 aligncenter" src="https://dalaoliblog.files.wordpress.com/2018/07/digital_fortress.jpg" alt="digital_fortress.jpg" width="187" height="269" /></p>
<p style="text-align:center;">（上图：丹布朗的小说《数字城堡》封面）</p>
<p>密码学安全算法我就不一一列举了，只说其中有一个，有一个以三个发明者名字首字母命名的B.B.S.算法。这个算法的安全性就是依靠数学中的所谓“二次剩余”问题：就是求x^2除某个数，在B.B.S算法中这个数是两个大素数相乘，求余数。你计算x^2除一个大数的余数很简单，但是它的逆运算，就是你需要找到一个完全平方数，使得它除以某个很大的数正好是某个余数，就难很多了。算法还有些其他细节，但总体上就是依靠了二次剩余问题的难度来确保了算法安全性。</p>
<p>密码学安全算法虽然“安全”，但你完全不必要在任何场合都是用这类算法，因为它们要比前面的LCG和梅森旋转慢许多，而且消耗更多内存资源。所以你一般应用中完全不需要用“密码学安全”算法。另外，当你需要密码学安全算法时，也需要很小心的挑选。有一个让人浮想联翩的新闻是2013年，有人发表了篇博客，指出美国国家安全局NSA推荐的一个“密码学安全”随机数算法中（ <a href="https://en.wikipedia.org/wiki/Dual_EC_DRBG">Dual_EC_DRBG</a>），所使用的参数是有弱点的，这就是一个后门！也就是这个算法本身没问题，但是NSA推荐的初始化参数是精心挑选过的，使得这个算法有了弱点，是有可能被推算出随机数。你如果用了NSA推荐的这些参数，那你的随机数就可能被美国国家安全局破解。这篇博客至今网上还能看到，我也没有看到NSA有任何回应，也没法回应了。这真的像小说情节，但现实中就发生了。</p>
<p>好了以上说了那么多算法，其实还漏了一个随机数算法中的要点，就是这个“种子”数的产生。前面说过了这个种子数决定了算法从其周期哪个位置开始产生随机序列。如果算法两次输出的种子数一样，或者太接近，那么你的输出立即或很快就发生重复了，这是我们不希望的。所以我们需要一个随机数来"启动"一个随机数算法，这就是种子。但这个种子就不能依靠算法来产生了，否则这就是死循环了。</p>
<p>前面说过可以用系统时间的毫秒数作为种子数，但有些场合，这还不够随机，你还是嫌重复几率太大。那就需要搜集计算机能搜集到的像“随机”情况的数值，或者叫“熵”。常见的方法有让用户随便敲几下键盘，移动几下鼠标，检测一下最近两次敲键的时间间隔，鼠标移动距离，CPU的温度，声卡传进来的噪音，如果是手机话还可以检查手机摆放的角度等等。总之，采集各种可以采集到的噪音数据，然后用算法混合起来，以便使整个种子数看上去最为“随机”，最难预测。</p>
<p>还有的软件为了安全性，规定产生若干个随机数后要重新产生一个种子，就是重置一次。像Linux操作系统就自带了两个随机数生成器(/dev/random, /dev/urandom)，其中一个(/dev/random)就需要不断重置种子，如果它搜集到的噪声不够多，它就会停下来，受到阻塞，直到搜集到足够多的噪声也就是熵之后才能继续。幸好，绝大多数场合下另一个不会阻塞的随机生成器已经是足够好用了。</p>
<p>最后，向大家介绍一个看上有点夸张，但确实在实际在使用的一个种子随机数生成器，叫“岩浆灯”，Lava Lamp。这种岩浆灯确实像一盏灯，也有点像沙漏，但里面并不是放岩浆，而是两种不同颜色的液体，这两种液体的比重差不多，但不会互相溶解。所以你就会看到这种岩浆灯里面的液体就不停的发生变动，比如一种颜色液体翻滚到上面，或者分裂成2团，或者又沉下去。这种变化看上去是完全随机的，物理老师会告诉我们这叫“布朗运动”。我也在节目介绍里放了一张这样的“岩浆灯“图片。</p>
<p><img class=" size-full wp-image-987 aligncenter" src="https://dalaoliblog.files.wordpress.com/2018/07/lava_lamp.jpg" alt="lava_lamp.jpg" width="275" height="183" /></p>
<p>这种岩浆灯最早是1990年代，SGI公司发明的，就是发布OpenGL这个图形软件库的厂商，他们还给注册了专利。1997到2001有家公司短暂用了这种岩浆灯，但商业化不成功，很快放弃。但后来2009年成立的，位于旧金山的一家叫Cloundflare的公司重新使用了这种岩浆灯。他们的业务中有重要的一块就是向客户提供网站需要的SSL证书。现在我们访问网站时，浏览器会时常提醒你这个网站有问题，证书不被信任等等，其实就是SSL证书在起作用。而要生成SSL证书，就需要产生随机数，要产生随机数，就要种子，他们就用岩浆灯来生成种子随机数。</p>
<p>他们还不是使用一盏岩浆灯，而是用数十盏岩浆灯，铺满一堵墙，然后用一个摄像头不断的去拍摄这面墙，因为岩浆灯不停的在变化，所以摄像头拍到的画面肯定也是不停的在变化，再加上摄像头拍摄也有噪点，温度湿度变化也对拍摄有影响等等，这些噪声结合在一起，那摄像头拍出的这幅画面用二进制来看确实是无法预测了。而且他们还在世界各地三个办公室都设置了这种岩浆灯，要三个办公室产生的随机数结合在一起混淆后才作为最后所使用的种子数。</p>
<p>听上去是不是为了一个产生随机数如此兴师动众是不是有点夸张，但这种岩浆灯确确实实在提供服务，而且估算现在互联网上10%的流量都是使用他们公司产生的SSL证书。不过我时常在想有必要这么兴师动众吗，干嘛不用中国很多地铁站的监控摄像头的图像，好像也一样效果：）</p>
<p>好了，有关软件随机数生成算法就到这里了，我最大感想是，生成安全可靠的随机数出人意料的难，而且到了几乎无所不用其极的地步。</p>
<p>有些听众也可能在想有没有硬件随机数生成器呢？当然有啊，比如福利彩票开奖用的那个吹乒乓球的机器，就是一个硬件随机数生成器啊。前面的岩浆灯也是，如果我们将来的电脑能内置一个丢硬币的装置，那也是一个硬件随机数生成器，开个玩笑了。但历史上确实有各种电脑上可以用的硬件随机数生成器，硬件的优越性就在于可以更多搜集环境噪音。</p>
<p><img class=" size-full wp-image-988 aligncenter" src="https://dalaoliblog.files.wordpress.com/2018/07/fulicaipiao.jpg" alt="fulicaipiao" width="300" height="168" /></p>
<p>目前有人在考虑就是使用量子的随机属性来产生随机数，比如电路的瞬间噪声，粒子的衰变时间，光子穿过半透玻璃的概率等等。这些量子行为是目前人类认为最为接近“真”随机的自然现象了。如果能有使用量子的随机性产生的随机数，那应该是最为安全和最为接近”真”随机数的随机数。</p>
<p>好了，有关随机数就聊到这里，我们下期再见！</p>
<hr />
<p><strong>大老李聊数学”第二季已开播！</strong>识别如下二维码即可：</p>
<p><img class="alignnone size-full wp-image-898" src="https://dalaoliblog.files.wordpress.com/2018/05/ximalaya_season1.png?w=1108" alt="ximalaya_season1.png" /></p>
<hr />
<p>关注“大老李聊数学”公众号，微信搜搜：dalaoli_shuxue</p>
<p>&nbsp;</p>
