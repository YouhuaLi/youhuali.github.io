---
layout: post
title: "“随机”不是“胡来”（1）--随机数的检验"
date: 2018-07-08 23:50:56.000000000 -07:00
type: post
parent_id: '0'
published: true
password: ''
key: page.kEElyH1S
status: publish
categories: []
tags: []
meta:
  _wpcom_is_markdown: '1'
  timeline_notification: '1531093861'
  _rest_api_published: '1'
  _rest_api_client_id: "-1"
  _publicize_job_id: '19806948776'
author:
  login: webcraft2013
  email: webcraft@gmail.com
  display_name: webcraft2013
  first_name: ''
  last_name: ''
---
<p>大家好，我是大老李。这期节目准备跟大家聊聊随机数。这个话题来自一位听众，想让我聊聊计算机是如何生成随机数的。我搜了一些资料，发现这是一个很有深度的话题，有关随机数有很多意向不到的陷阱和反直觉的一些事情。而我发现，从检验随机数这个话题开始，可以帮助大家更好理解，等下期我们再聊怎么生成随机数。</p>
<p>要说怎么检验随机数，我们还是考虑一个最简单的例子，如果我想让你生成一串0和1的数字序列，而且符合所谓0-1二项分布，0和1的概率各50%，你会怎么做？当然，这很简单，你可以拿一枚硬币不停的丢，看到正面写个0，背面写个1。当然，也会有偷懒的朋友会说，我直接瞎写就可以了，只要我0和1写的总数差不多就可以了。现在问题是，如果我给你两个0-1的序列，其中一个是某人用丢硬币的方法产生的，另一个是某人“随便”手写产生的，请问你有办法鉴别出来这两个序列哪个是丢硬币产生的，哪个是“手写”产生的？</p>
<p>其实稍微思考下，你就会发现，只要你给我的两个序列足够长，我就能鉴别出来。因为随机数是有特征的，我们课堂上都学过，比如期望值，方差，等等。那对这个0-1的序列，我当然会先考察下0和1的数量是不是差不多。就算你手写的时候非常小心，把0和1写的很均匀，那还有好多其他特征可以考察。</p>
<p>这个例子里，如果0和1的数量符合期望了，那方差也是没问题的。但我们可以考虑比如其中的最长的连续的1的序列，就是连着出现多个1的情况。如果10000个0-1的随机序列，里面连续最长的1的长度只有4，那我凭直觉也知道这个序列是有问题了。虽然从某个特定位置开始连续出现5个1的概率是1/32，但是在1万个数字里一次也没发生的概率，我粗糙算下大约只有10^(-35)这个数量级（大老李的“糙算”，如有准确算法，也请告知）。事实，在长度1万的0-1随机序列里，最长的连续1的长度，大致是在9到15之间。</p>
<p>以上例子就是说明，用“瞎写”的方式产生的随机数，并不是“真正”的随机数，有很多方法可以鉴别出这种假随机数。那我们为什么需要检验随机数呢？这可太重要了，小到一个游戏程序，大到一次彩票开奖，或者信息的加密传输，这些都需要随机数。如果你的随机数不够“随机”，那就会让人有机可乘，这个后果可大可小，但对银行，军事部门来说，他们对随机数的要求肯定是非常高的。</p>
<p>那又有一个问题，究竟什么是真正的“随机”？很意外，这是一个非常微妙甚至哲学化的问题。比如丢硬币产生的序列算不算随机呢？看上去是随机的，但是正如很多文章里说的，如果硬币丢出去以后，如果所有的物理参数我都知道了，比如初速度，角度，空气阻力，湿度，硬币密度，形状等等所有与硬币落下后相关的参数都已知，并且我有一个计算速度极快的计算机，那我就可以计算出硬币落下后“将“会正面还是背面，那丢硬币结果还算不算随机数的？爱因斯坦甚至有句名言叫“上帝不掷骰子”。今天我们不能扯远去聊物理相关话题，我只是什么是真正的随机数，自然界中有没有随机现象至今还是一个有争议也十分微妙的问题。</p>
<p>但数学里，特别是密码学里，还是给“真”随机数给出了一个定义，比如”真正”的符合1/2对1/2概率的0-1二项分布的随机变量定义就是这样：设想一个游戏，我是给出0-1分布随机数的，你是猜随机数的。我每次会产生一个0或1的随机数，你要去猜。你有几个便利条件，我允许你在猜之前向我要任意多的数量的随机数。也就是说，你可以研究过往随机数的历史，如果你认为这对下一次猜测有用的话。而且你想要多少我就给你多少，这是一个便利条件。另一个便利条件是你有一个无限计算能力的计算机，要多块就多块，也就是你可以尽情的在猜之前利用这台机器机去分析，甚至于我可以先产生一个新的随机数，但不给你去看，你还是尽可以去算。等你觉得算够的时候，你就可以猜0或是1。而所谓“真”随机数就是，这个游戏经过非常多次之后，你能猜对的概率仍然是½，那么我产生的随机数就是所谓“真”0-1二项均匀分布。</p>
<p>如果最后这句话你认为还不够精确的话，我可以用数学语言重新叙述下就是：对任意小的ε，存在一个Δ，当游戏次数进行大于等于Δ次之后，你猜中的次数除以游戏总次数的比值-1/2的绝对值，总会小于ε。好了，以上就是完美随机数的定义，是不是出奇的啰嗦，但是以上条件缺一不可。首先，我得允许你看历史随机数，真正的随机数是与历史无关的，所以你如果能通过学习历史哪怕使你的猜测的成功率增加0.00001，那这个随机数就是失败的。而且我得允许你有无限计算能力的计算机，你不能因为是别人计算速度不够导致猜不准，理由跟之前一样，就是随机数就是独立事件，与之前的结果无关。最后要注意的是，你猜测的结果最后与0.5比较是要取绝对值的，就是你猜对或者猜错的“能力”都要能“收敛”在0.5上。如果你有了大于0.5几率的“猜错”能力，那等价于你有了“猜对”的能力，这也是不行的。</p>
<p>以上我们虽然有了完美随机数的定义，但实践中这个定义却没有什么用，因为以上这个游戏纯属理想试验，我没法保证在我人生有限时间里给你任意长度的随机数，你也根本没有任意算力的计算机。所以我们产生随机数，特别是用软件产生的随机数，只能尽量去接近这个标准，而无法达到这一标准。下一期会具体讲讲计算机产生随机数的方法。</p>
<p>今天还是先说说随机数的检验，这里说的随机数的检验主要是对计算机随机数生成算法的检验。以下我们从最简单的测试开始：</p>
<p>第一级测试就是：范围测试，就是测试你的产生的随机数是不是都位于目标范围。这个测试意义比较简单，如果你的随机数的范围是0到1之间，那么我测试发现你产生了小于0或者大于1的随机数，那肯定是你的算法有问题了。但是边界上还是需要注意。比如你的算法是期望产生大于0小于等于1的范围，但是实际算法不能产生1，或者会产生0，但是概率都很小，那么测试软件就可能发现不了这些问题。这种问题是很难通过软件发现的，只能靠人为去分析算法来验证。</p>
<p>第二级测试就是均值测试，就是看期望值。比如你的随机数如果期望值是100，那我就跑1万个随机值出来，求个平均值，看看是不是够接近100。另外学过概率的人应该知道“置信空间”这个概念，也就是我可以计算出我这一万个随机数平均值有比如95%的概率应该是在怎样的区间内，比如是100+-5的范围，如果算出来平均值是106，那我就有95%的把握说你的算法是有问题的。</p>
<p>第三级测试就是所谓方差测试，就是看变量的变化程度。前面说了均值测试，如果我的均值的期望值是100，然后我发现每次测试一万个随机数的平均值，都是恰好100，不多不少。如果1次这样我还信，给我来10次都正好100，那无论如何我都不信这是随机数序列！这里再一次有所谓置信空间，我可以知道随机数的变化分布程度是否在我预设的置信空间内。</p>
<p>以上我们测试里随机变量的均值和方差，这是随机变量的两个基本特征。但即使符合这两个特征了，也不表示你的算法就是对的。比如对期望值是1的指数分布，和期望值是1且方差也是1的正态分布，这两种分布的期望值和方差都是1。如果你不小心在应该产生正态分布随机数的代码里，用了产生指数分布的算法，那用以上两种测试就测不出区别了。这是就需要第三级测试，叫“分桶”测试(Bucket Test)，水“桶”的桶。这也好理解，概率教科书里都给我们画过每种概率分布的概率密度函数，正态分布是所谓像一口倒扣的钟的形状的“钟形曲线”，指数分布是从左上到右下下降的曲线。要区分这两种情况，我就可以把在x坐标轴上等距离取若干个点，然后画垂线，每两条垂线之间就是一个个“桶”，然后考察随机变量落到不同的桶中的数量。比如对正态分布，我知道在期望值两边对称的桶里的变量数量应该是差不多多的，但是对于指数分布，左边的桶就要比右边的桶里的变量数量要多。这样，我就能区分出两种分布。</p>
<p>桶测试已经是非常细致的测试了，但是桶测试的精度跟桶划分的密度有关，不管怎么划分，你也只能划分有限多个桶，你还是有小概率使得你的算法在某个桶内的狭小范围内失真。所以，这里有个终极测试叫柯尔莫哥罗夫-斯米尔诺夫检验（Kolmogorov-Smirnov test），简称KS测试。一听这个名字你就知道这都是俄罗斯的数学家。这个测试的基本理念就是画出（准确来讲是拟合）测试样本的概率累积函数图像，然后与理论上的经验累积函数图像比较。有时是取两组测试样本画出两条概率累积函数图像互相比较。这个概率累积函数大家课本上也应该讲过，就是函数值从0变化到1的一条曲线，其实就是概率密度函数的积分函数图像。先不管这具体函数定义，但可以想象如果算法是对的，那我的样本你拟合出来的累积函数图像应该是比较接近经验概率累积函数图像的，虽然总有些误差。这个KS测试就是取你的实验结果的函数图像与理论图像在某个垂直线上的最大差值。如果这个差值大到我们事先设定的某个“阈值”，或者说这个差值足够“显著”，那我们就要考虑我们的随机数算法就是有问题了。当然，虽然我说的如此简单，但是实际这个这个测试是有相当复杂数学依据的，也就是这个检验可以定量的告诉你这个最大误差K发生的概率是多少，或者在一定执行空间内， 这个误差应该在什么范围。</p>
<p>[gallery ids="981,982" type="rectangular"]</p>
<p>（左图：红线为理论概率分布函数，蓝色为实验数据。右图：红和蓝线都是实验数据。黑色箭头为两条曲线垂直方向上最大差值，即为判断数据是否符合概率分布的依据，称为KS统计值）</p>
<p>这个KS测试已经是相当优秀的，它也有一些变体测试，比如Shapiro–Wilk test or Anderson–Darling test.，每种测试都各有利弊，这里大老李就没法一一细数了。</p>
<p>关于随机数的测试，基本就是以上这些了，下一期大老李会具体讲讲计算机是怎么产生随机数的。有意思的是能够通过以上这些测试的随机数算法，并不一定是“安全”的算法，也就是没法用在需要严格加密领域的随机数生成。而有些被证明是非常安全的随机数算法，并不能保证每次都能通过以上测试，尤其是桶测试和KS测试。这也是可以理解，因为随机数本就是随机嘛，如果它的行为100%的能通过测试，那它也不随机了。这就是随机数的微妙和有趣之处。好，我们下期再见。</p>
<hr />
<p><strong>大老李聊数学”第二季已开播！</strong>识别如下二维码即可：</p>
<p><img class="alignnone size-full wp-image-898" src="https://dalaoliblog.files.wordpress.com/2018/05/ximalaya_season1.png?w=1108" alt="ximalaya_season1.png" /></p>
<hr />
<p>关注“大老李聊数学”公众号，微信搜搜：dalaoli_shuxue</p>
<p>&nbsp;</p>
