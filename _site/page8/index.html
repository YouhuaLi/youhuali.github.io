<!DOCTYPE html><html lang="zh">
  <head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no"><title>主页 - 大老李聊数学</title>

<meta name="description" content="基本都是“大老李聊数学”音频节目讲稿 继续以半专业的好奇心解读专业的数学知识，给您轻松愉快的收听体验，带来更多好玩有意思的数学内容。 用收听的方式理解数学，跟您聊聊公理，悖论，数论，函数等各种数学相关话题。还会不定期汇报数学界最新成果和新闻。
">
<link rel="canonical" href="http://localhost:4000/page8/"><link rel="alternate" type="application/rss+xml" title="大老李聊数学" href="/feed.xml">
<!-- begin favicon --><link rel="apple-touch-icon" sizes="180x180" href="/assets/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicon-16x16.png"><link rel="manifest" href="/assets/site.webmanifest"><link rel="mask-icon" href="/assets/safari-pinned-tab.svg" color="#fc4d50"><link rel="shortcut icon" href="/assets/favicon.ico">

<meta name="msapplication-TileColor" content="#ffc40d"><meta name="msapplication-config" content="/assets/browserconfig.xml">

<meta name="theme-color" content="#ffffff">
<!-- end favicon --><link rel="stylesheet" href="/assets/css/main.css"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" >
<script>(function() {
  window.isArray = function(val) {
    return Object.prototype.toString.call(val) === '[object Array]';
  };
  window.isString = function(val) {
    return typeof val === 'string';
  };

  window.decodeUrl = function(str) {
    return str ? decodeURIComponent(str.replace(/\+/g, '%20')) : '';
  };


  window.hasEvent = function(event) {
    return 'on'.concat(event) in window.document;
  };

  window.isOverallScroller = function(node) {
    return node === document.documentElement || node === document.body || node === window;
  };

  window.pageLoad = (function () {
    var loaded = false, cbs = [];
    window.addEventListener('load', function () {
      var i, cb; loaded = true;
      if (cbs.length > 0) {
        for (i = 0; i < cbs.length; i++) {
          cb = cbs[i]; cb();
        }
      }
    });
    return {
      then: function(cb) {
        cb && (loaded ? cb() : (cbs.push(cb)));
      }
    };
  })();
})();(function() {
  window.throttle = function(func, wait) {
    var args, result, thisArg, timeoutId, lastCalled = 0;

    function trailingCall() {
      lastCalled = new Date;
      timeoutId = null;
      result = func.apply(thisArg, args);
    }
    return function() {
      var now = new Date,
        remaining = wait - (now - lastCalled);

      args = arguments;
      thisArg = this;

      if (remaining <= 0) {
        clearTimeout(timeoutId);
        timeoutId = null;
        lastCalled = now;
        result = func.apply(thisArg, args);
      } else if (!timeoutId) {
        timeoutId = setTimeout(trailingCall, remaining);
      }
      return result;
    };
  };
})();(function() {
  var Set = (function() {
    var add = function(item) {
      var i, data = this._data;
      for (i = 0; i < data.length; i++) {
        if (data[i] === item) {
          return;
        }
      }
      this.size ++;
      data.push(item);
      return data;
    };

    var Set = function(data) {
      this.size = 0;
      this._data = [];
      var i;
      if (data.length > 0) {
        for (i = 0; i < data.length; i++) {
          add.call(this, data[i]);
        }
      }
    };
    Set.prototype.add = add;
    Set.prototype.get = function(index) { return this._data[index]; };
    Set.prototype.has = function(item) {
      var i, data = this._data;
      for (i = 0; i < data.length; i++) {
        if (this.get(i) === item) {
          return true;
        }
      }
      return false;
    };
    Set.prototype.is = function(map) {
      if (map._data.length !== this._data.length) { return false; }
      var i, j, flag, tData = this._data, mData = map._data;
      for (i = 0; i < tData.length; i++) {
        for (flag = false, j = 0; j < mData.length; j++) {
          if (tData[i] === mData[j]) {
            flag = true;
            break;
          }
        }
        if (!flag) { return false; }
      }
      return true;
    };
    Set.prototype.values = function() {
      return this._data;
    };
    return Set;
  })();

  window.Lazyload = (function(doc) {
    var queue = {js: [], css: []}, sources = {js: {}, css: {}}, context = this;
    var createNode = function(name, attrs) {
      var node = doc.createElement(name), attr;
      for (attr in attrs) {
        if (attrs.hasOwnProperty(attr)) {
          node.setAttribute(attr, attrs[attr]);
        }
      }
      return node;
    };
    var end = function(type, url) {
      var s, q, qi, cbs, i, j, cur, val, flag;
      if (type === 'js' || type ==='css') {
        s = sources[type], q = queue[type];
        s[url] = true;
        for (i = 0; i < q.length; i++) {
          cur = q[i];
          if (cur.urls.has(url)) {
            qi = cur, val = qi.urls.values();
            qi && (cbs = qi.callbacks);
            for (flag = true, j = 0; j < val.length; j++) {
              cur = val[j];
              if (!s[cur]) {
                flag = false;
              }
            }
            if (flag && cbs && cbs.length > 0) {
              for (j = 0; j < cbs.length; j++) {
                cbs[j].call(context);
              }
              qi.load = true;
            }
          }
        }
      }
    };
    var load = function(type, urls, callback) {
      var s, q, qi, node, i, cur,
        _urls = typeof urls === 'string' ? new Set([urls]) : new Set(urls), val, url;
      if (type === 'js' || type ==='css') {
        s = sources[type], q = queue[type];
        for (i = 0; i < q.length; i++) {
          cur = q[i];
          if (_urls.is(cur.urls)) {
            qi = cur;
            break;
          }
        }
        val = _urls.values();
        if (qi) {
          callback && (qi.load || qi.callbacks.push(callback));
          callback && (qi.load && callback());
        } else {
          q.push({
            urls: _urls,
            callbacks: callback ? [callback] : [],
            load: false
          });
          for (i = 0; i < val.length; i++) {
            node = null, url = val[i];
            if (s[url] === undefined) {
              (type === 'js' ) && (node = createNode('script', { src: url }));
              (type === 'css') && (node = createNode('link', { rel: 'stylesheet', href: url }));
              if (node) {
                node.onload = (function(type, url) {
                  return function() {
                    end(type, url);
                  };
                })(type, url);
                (doc.head || doc.body).appendChild(node);
                s[url] = false;
              }
            }
          }
        }
      }
    };
    return {
      js: function(url, callback) {
        load('js', url, callback);
      },
      css: function(url, callback) {
        load('css', url, callback);
      }
    };
  })(this.document);
})();</script><script>
  (function() {
    var TEXT_VARIABLES = {
      sources: {
        font_awesome: 'https://use.fontawesome.com/releases/v5.0.13/css/all.css',
        jquery: 'https://cdn.bootcss.com/jquery/3.1.1/jquery.min.js',
        leancloud_js_sdk: '//cdn1.lncld.net/static/js/3.4.1/av-min.js',
        chart: 'https://cdn.bootcss.com/Chart.js/2.7.1/Chart.bundle.min.js',
        gitalk: {
          js: 'https://cdn.bootcss.com/gitalk/1.2.2/gitalk.min.js',
          css: 'https://cdn.bootcss.com/gitalk/1.2.2/gitalk.min.css'
        },
        mathjax: 'https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML',
        mermaid: 'https://cdn.bootcss.com/mermaid/7.1.2/mermaid.min.js'
      },
      site: {
        toc: {
          selectors: 'h1,h2,h3'
        }
      },
      paths: {
        search_js: '/assets/search.js'
      }
    };
    window.TEXT_VARIABLES = TEXT_VARIABLES;
  })();
</script></head>
  <body>
    <div class="root" data-is-touch="false">
      <div class="layout--page js-page-root"><div class="page__main js-page-main">

    <div class="page__main-inner">
      <div></div><div class="page__header"><header class="header"><div class="main">
      <div class="header__title">
        <div class="header__brand"><svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 width="24px" height="24px" viewBox="0 0 24 24">
<style type="text/css">
	.st0{fill:#515151;}
</style>
<path class="st0" d="M1.7,22.3c5.7-5.7,11.3-5.7,17,0c3.3-3.3,3.5-5.3,0.8-6c2.7,0.7,3.5-1.1,2.3-5.6s-3.3-5.2-6.3-2.1
	c3-3,2.3-5.2-2.1-6.3S7,1.8,7.7,4.6C7,1.8,5,2.1,1.7,5.3C7.3,11,7.3,16.7,1.7,22.3"/>
</svg><a title="基本都是“大老李聊数学”音频节目讲稿 继续以半专业的好奇心解读专业的数学知识，给您轻松愉快的收听体验，带来更多好玩有意思的数学内容。 用收听的方式理解数学，跟您聊聊公理，悖论，数论，函数等各种数学相关话题。还会不定期汇报数学界最新成果和新闻。
" href="/">大老李聊数学</a></div>
        <button class="button button--secondary button--circle search-button js-search-toggle"><i class="fas fa-search"></i></button>
      </div><nav class="navigation">
        <ul><li class="navigation__link"><a href="/archive.html">归档</a></li><li class="navigation__link"><a href="/about.html">关于</a></li><li><button class="button button--secondary button--circle search-button js-search-toggle"><i class="fas fa-search"></i></button></li>
        </ul>
      </nav></div>
  </header>
</div><div class="page__content"><div class ="main"><div class="grid grid--reverse">

             <div class="col-aside js-col-aside"></div>

            <div class="col-main cell--auto"><article itemscope itemtype="http://schema.org/WebPage"><div class="article__header"><header style="display:none;"><h1>主页</h1></header></div><meta itemprop="headline" content="主页"><meta itemprop="author" content="大老李"/><div class="js-article-content"><div class="layout--home"><div class="items items--divided"><article class="item" itemscope itemtype="http://schema.org/BlogPosting"><div class="item__content">
          <header><h2 itemprop="headline" class="item__header"><a href="/2017/11/26/e6-af-8f-e5-91-a8-e4-b8-80-e9-a2-98-ef-bc-9a-e8-83-bd-e5-8f-98-e6-88-90-e4-b8-80-e6-a0-b7-e9-a2-9c-e8-89-b2-e5-90-97-ef-bc-9f-ef-bc-88-e9-99-84-e4-b8-8a-e5-91-a8-e7-ad-94-e6-a1-88-ef-bc-89.html">每周一题：能变成一样颜色吗？ （附上周答案）</a></h2></header>
          <div class="item__description"><div class="article__content" itemprop="description articleBody"><h1>本周题目：能变成一样颜色吗？</h1>
<p>本期题目取自俄罗斯某数学竞赛题。某岛屿上有一群变色龙。现在有13只绿色的，15只蓝色的和17只红色变色龙。每当两只不同颜色的变色龙靠近时，它们都会变成第三种颜色。那么它们有可能变成同一种颜色吗？</p>
<p>&nbsp;</p>
<p><img class="alignnone size-full wp-image-727" src="https://dalaoliblog.files.wordpress.com/2017/11/bianselong.jpg" alt="bianselong" width="275" height="183" /></p>
<hr />
<h1>上期答案：</h1>
<p>上周题目是：</p>
<blockquote><p>如下图，有一个半径为<strong>2</strong>的小圆，沿半径为<strong>10</strong>的大圆逆时针运动，移动半个圆周后，沿一个半径为<strong>5</strong>的圆继续运动半个圆周。运动过程中，橙色圆圆心始终保持在其他圆上。为橙色圆扫过的面积多大，即图右阴影部分（包含橙色圆本身）？</p>
<p>提示：无需高等数学，耐心将图形分解，分部计算。</p>
<p><img class="alignnone size-full wp-image-706" src="https://dalaoliblog.files.wordpress.com/2017/11/roeder-riddler-2-110917.png" alt="roeder-riddler-2-110917" width="1150" height="642" /></p></blockquote>
<p>这期题目比较简单，答案是$latex 64\pi$。答对的朋友有(如有遗漏请见谅)：<strong>黄亮，今年不买表，李凯峰_3g，Matody</strong> 。</p>
<p>解法看这个图就明白了：</p>
<p><img class="alignnone size-full wp-image-726" src="https://dalaoliblog.files.wordpress.com/2017/11/64pi.png" alt="64pi.png" width="1150" height="193" /></p>
<p>另外还有两位朋友(<strong>567</strong>和<strong class="nickname">吃喵个鱼</strong>)提出这种解法：大圆半周长＋小圆半周长，然后乘以小球半径，然后再加上小球的面积。你看，微积分思想就是这样孕育出来的。下周再见！</p>
<p>收听“大老李聊数学”音频                                        关注“大老李聊数学”</p>
<p>[gallery ids="380,151" columns="2"]</p>
<p>&nbsp;</p>
</div><p><a href="/2017/11/26/e6-af-8f-e5-91-a8-e4-b8-80-e9-a2-98-ef-bc-9a-e8-83-bd-e5-8f-98-e6-88-90-e4-b8-80-e6-a0-b7-e9-a2-9c-e8-89-b2-e5-90-97-ef-bc-9f-ef-bc-88-e9-99-84-e4-b8-8a-e5-91-a8-e7-ad-94-e6-a1-88-ef-bc-89.html">阅读更多</a></p></div><div class="article__info clearfix"><ul class="right-col menu"><li><i class="fas fa-user"></i> <span>大老李</span></li><li><i class="far fa-calendar-alt"></i> <span>2017年 11月26日</span>
            </li></ul></div><meta itemprop="author" content="大老李"/><meta itemprop="datePublished" content="2017-11-26T09:51:44+00:00"></div>
      </article><article class="item" itemscope itemtype="http://schema.org/BlogPosting"><div class="item__content">
          <header><h2 itemprop="headline" class="item__header"><a href="/2017/11/20/e7-a5-9e-e7-a7-98-e7-9a-840-577-e6-ac-a7-e6-8b-89-e9-a9-ac-e6-96-af-e5-88-bb-e8-8b-a5-e5-b0-bc-e5-b8-b8-e6-95-b0.html">神秘的0.577--欧拉-马斯刻若尼常数</a></h2></header>
          <div class="item__description"><div class="article__content" itemprop="description articleBody"><p>大家好，我是大老李。今天想跟大家聊个数学中的常数，这个常数虽不如$latex \pi$或e这么著名，但是它很有趣，略带神秘感。要知道这个常数的来由，我们可以先从一个小故事开始。</p>
<p>有一只蚂蚁，在一根橡皮绳上的一端，橡皮绳初始长度为1m，然后蚂蚁开始爬，它的爬行速度是每秒1cm，但橡皮绳每1秒后，又会均匀拉伸1m长，也就是1秒后，绳子变2米，再一秒后，变3米长，等等。问你这只蚂蚁能否爬到橡皮绳的另一端？</p>
<p>你的第一感觉肯定是这怎么可能爬的完？但是答案确实是能够爬完，不信我们来算一下。比如第一秒，绳子长1米，蚂蚁前进了1厘米，那么蚂蚁前进了总长的1/100；第二秒，绳子长2米，蚂蚁又前进了1厘米，那么蚂蚁前进了总长的1/200，因为绳子是均匀拉伸的。那第三秒，蚂蚁又能前进1/300；一次类推，第n秒后，蚂蚁爬完的绳长比例就是1/100+1/200+1/300+...1/n*100。现在这个问题就变成了上面这个数列之和有没有可能加到1也就是100%。对这个数列，我们把1/100这个公分母提取到最外面，那它就变成$latex 1/100*(1+1/2+1/3+1/4+...+1/n)$。这时，你应该看出点啥了，这个括号的级数就是所有自然数的倒数，也叫调和级数。你可能已经知道调和级数是发散的，也就是在项数足够多之后，这个级数和可以是任意大。所以上面的问题就是，当调和级数累加到100时，蚂蚁能够爬完绳子。</p>
<p>我第一次看到这个问题的时候，是相当震惊的，因为它实在是太反直觉了。理解问题关键就在于每次绳子拉长是，蚂蚁身后的距离也在拉长，所以蚂蚁总体上完成的比例还是在增加的，经过非常非常慢。而对所有自然数的倒数是发散的这一事实。如果你不确定，你可以上网找一下调和级数发散的证明。这个证明非常简单，最早14世纪中世纪晚期的一位哲学家奥里思姆就发现过的。而且这个证明是用的所谓缩放法，就是把调和级数的某些项换成比它更小的数字，得到另一个数列，结果这个更小的数列仍然发散。这就提示我们调和级数不但发散，而且发散的够彻底，或者说还有不少余地，哪怕再缩小点，仍然发散。这一点我们之后还会看到一个例子。</p>
<p>那现在你可能关心调和级数的前n项和到底是啥？能不能快速计算出来？ 答案是它大约是$latex \ln{N}$，即N的自然对数。其实这一点学过微积分的听众会比较容易理解，因为$latex \ln{N}$的导函数是1/N。调和级数的求和，就很像求1/x的函数曲线与x轴之间，从x=1开始到x=n之间的面积。这个面积自然就是$latex \ln{N}-\ln{1}=\ln{N}$。由此我们也可以推算出节目开始时的蚂蚁要爬完那根绳子所需时间，也就是要让调和级数部分和大于100的时候，那就需要$latex \ln{N}\ge100$，也即是需要约$latex e^{100}$次方秒，约等于$latex 10^{36}$年，这个时间足够宇宙诞生再毁灭无数轮了。所以，你也不能说直觉不对，因为这个时间已经大到人难以理解的地步。</p>
<p>那既然调和级数前n项和是趋向于$latex \ln{N}$，那它是不是最终就等于$latex \ln{N}$呢？或者说用我们上一期节目提到过的“任意大”和“充分大”这两个术语来说，是不是N充分大之后，调和级数的前N项和与$latex \ln{N}$之间的差可以是任意小呢？答案是否定的，但它们之间会有一个有限的差值，这个差值就是今天节目标题中的欧拉-马斯刻若尼常数。为什么说这个常数有点神秘呢，因为如果这个差值是已知的常数比如pi或e或者是能用它们表示出来，那就不神秘了。但这确确实实是一个独立的新常数值。而且这个常数的定义其实是很简单的，我在节目介绍里放了一张图，这张图就是体现这个常数在几何上的含义，非常直观，强烈推荐你看下。</p>
<p><img class="alignnone size-full wp-image-712" src="https://dalaoliblog.files.wordpress.com/2017/11/602px-integral_test-svg.png" alt="602px-Integral_Test.svg.png" width="602" height="468" /></p>
<p>(上图中，黄色部分位于1/x曲线之上的部分面积之和，即为欧拉-马斯刻若尼常数)</p>
<p>这个常数如名称所示，最早是欧拉发现的，他把这个常数算到了小数点之后6位，前三位是0.577。之后到1790年，意大利人马斯刻若尼把它算到了小数点后32位，但可惜其中有三位，后来被发现他算错了。尽管如此，人们还是把这个常数被称作欧拉-马斯刻若尼常数。当然，另一个原因是欧拉的发现太多了，如果叫欧拉常数，人们常常搞不清楚具体是哪个欧拉常数。现在我们用计算机已经把这个常数算到小数点后100亿位以上，至今没有发现有循环的迹象。当然你可能很确信它是一个无理数，数学家也普遍认为它是一个超越数，但是至今还没有人能证明它是无理数。这又给它平添了一些神秘感。</p>
<p>为你更好理解，我还可以用前面那个蚂蚁的爬行的比喻。你可以想象一下，如果我们的橡皮绳不是在每一秒的结束时刻突然增加1m，而是按每秒1m的速度匀速拉长，那么蚂蚁需要爬行的时间就会短一点，因为绳子每时每刻拉长，也就是长度有更多的部分在蚂蚁的身后被拉长。那么这种情况下，按照我们原版故事的数值设定，这次蚂蚁在足够长的时间之后，它爬过的距离，会比原版故事的蚂蚁多0.577%。虽然比例很小，但是绝对时间差值还是会非常巨大。这个常数还有一些有意思的性质，比如与Gamma函数的关系，我就不在节目里念了，各位有兴趣的可以自行研究。</p>
<p>最后聊一个调和级数的扩展话题。前面说过调和级数发散的很彻底，你把级数里抽掉很多项它还是发散。最令人吃惊的就是欧拉还证明过所有素数的倒数和也是发散的。不久前节目里我就说过，素数在自然数里的比例是少的，“几乎所有的自然数都是合数”，但是调和级数里，你把占绝大多数的合数的倒数全部丢掉后，居然还是发散的。还是用蚂蚁的爬行故事说明的话，就是说橡皮绳的拉伸不是每秒拉长一米，而是每妙钟后，绳子的长度按素数序列变化，就是2m, 3m, 5m, 7m, 11m, 这样下去，结果蚂蚁还是能爬完的！不过此时蚂蚁需要花的时间是$latex e^{e^{100}}$方秒，我们还是放过那只蚂蚁吧。</p>
<p>到这里你也许在想自然数的平方倒数和，立方倒数和的情况，这些级数都是收敛的，而且都是一些很有意思的话题，我想放在以后的节目讲。</p>
<p>这个常数差不多讲到这里，这个常数如同数学中很多优美的常数一样，它概念简单，但含义深刻。将来我也会陆续给大家介绍些其他常数。听众也可以好好的搜集下身边的数字，做些统计，大胆猜想，小心求证，说不定又一个新的常数隐藏在哪里。</p>
<p>另外我继续欢迎各位听众提供节目线索，我最近也开通了喜马拉雅的问答功能，欢迎大家向我提问！下期再见!</p>
<p>收听“大老李聊数学”</p>
<p><img class="alignnone  wp-image-380" src="https://dalaoliblog.files.wordpress.com/2017/10/ximalaya.png" alt="ximalaya" width="324" height="311" /></p>
<p>订阅“大老李聊数学”：</p>
<p><img class="alignnone size-full wp-image-151" src="https://dalaoliblog.files.wordpress.com/2017/09/qrcode_for_gh_130ed4d8263c_344.jpg" alt="qrcode_for_gh_130ed4d8263c_344" width="344" height="344" /></p>
</div><p><a href="/2017/11/20/e7-a5-9e-e7-a7-98-e7-9a-840-577-e6-ac-a7-e6-8b-89-e9-a9-ac-e6-96-af-e5-88-bb-e8-8b-a5-e5-b0-bc-e5-b8-b8-e6-95-b0.html">阅读更多</a></p></div><div class="article__info clearfix"><ul class="right-col menu"><li><i class="fas fa-user"></i> <span>大老李</span></li><li><i class="far fa-calendar-alt"></i> <span>2017年 11月20日</span>
            </li></ul></div><meta itemprop="author" content="大老李"/><meta itemprop="datePublished" content="2017-11-20T13:38:21+00:00"></div>
      </article><article class="item" itemscope itemtype="http://schema.org/BlogPosting"><div class="item__content">
          <header><h2 itemprop="headline" class="item__header"><a href="/2017/11/18/e6-af-8f-e5-91-a8-e4-b8-80-e9-a2-98-ef-bc-9a-e9-98-b4-e5-bd-b1-e9-83-a8-e5-88-86-e9-9d-a2-e7-a7-af-e5-a4-9a-e5-a4-a7-ef-bc-9f-ef-bc-88-e9-99-84-e4-b8-8a-e5-91-a8-e7-ad-94-e6-a1-88-ef-bc-89.html">每周一题：阴影部分面积多大？ （附上周答案）</a></h2></header>
          <div class="item__description"><div class="article__content" itemprop="description articleBody"><h1>本周题目：阴影部分面积多大？</h1>
<p>如下图，有一个半径为<strong>2</strong>的小圆，沿半径为<strong>10</strong>的大圆逆时针运动，移动半个圆周后，沿一个半径为<strong>5</strong>的圆继续运动半个圆周。运动过程中，橙色圆圆心始终保持在其他圆上。为橙色圆扫过的面积多大，即图右阴影部分（包含橙色圆本身）？</p>
<p>提示：无需高等数学，耐心将图形分解，分部计算。<img class="alignnone size-full wp-image-706" src="https://dalaoliblog.files.wordpress.com/2017/11/roeder-riddler-2-110917.png" alt="roeder-riddler-2-110917" width="1150" height="642" /></p>
<p>&nbsp;</p>
<hr />
<h1>上期答案：</h1>
<p>上周题目是：</p>
<blockquote><p><strong>冯诺依曼</strong>曾经出过这么一道有趣的题目：你有一枚不均匀的硬币，它掷出去正反面向上的概率不等，你也不知道具体哪面向上的概率高，概率是多少。请问，你能否用这枚硬币产生<strong>50%</strong>的概率事件？或者说，你可以用这枚硬币<strong>公平</strong>的与别人打赌？</p>
<p>要求：只能用投掷硬币的动作，只有一枚这样的硬币，不能使用其他工具。</p>
<p>提示：可以投掷不止一次，别想太复杂。</p></blockquote>
<p>很多读者想出了这样的办法：两人轮流掷，看谁先掷出最多的正面或背面，类似于足球比赛的罚点球。此方法可以，但太过复杂。</p>
<p>冯诺依曼给出的方法是：</p>
<p>你可以这样打赌说：我们分别选择“正反”或“反正”，连掷两次这枚硬币，看先出现“正反”还是“反正”，先出现为胜者。如果结果是“正正”或“反反”则重掷。</p>
<p>以上方法不但简单明了，而且操作性也很强啊！下周再见！</p>
<p>收听“大老李聊数学”音频                                        关注“大老李聊数学”</p>
<p>[gallery ids="380,151" columns="2"]</p>
<p>&nbsp;</p>
</div><p><a href="/2017/11/18/e6-af-8f-e5-91-a8-e4-b8-80-e9-a2-98-ef-bc-9a-e9-98-b4-e5-bd-b1-e9-83-a8-e5-88-86-e9-9d-a2-e7-a7-af-e5-a4-9a-e5-a4-a7-ef-bc-9f-ef-bc-88-e9-99-84-e4-b8-8a-e5-91-a8-e7-ad-94-e6-a1-88-ef-bc-89.html">阅读更多</a></p></div><div class="article__info clearfix"><ul class="right-col menu"><li><i class="fas fa-user"></i> <span>大老李</span></li><li><i class="far fa-calendar-alt"></i> <span>2017年 11月18日</span>
            </li></ul></div><meta itemprop="author" content="大老李"/><meta itemprop="datePublished" content="2017-11-18T13:39:59+00:00"></div>
      </article><article class="item" itemscope itemtype="http://schema.org/BlogPosting"><div class="item__content">
          <header><h2 itemprop="headline" class="item__header"><a href="/2017/11/15/e6-af-94-e7-89-b9-e5-b8-81-e5-8e-9f-e7-90-86-e6-b5-85-e8-af-b4-ef-bc-88-e4-b8-8b-ef-bc-89.html">比特币原理浅说（下）</a></h2></header>
          <div class="item__description"><div class="article__content" itemprop="description articleBody"><p>大家好，我是大老李，上一期跟大家聊了比特币当中的非对称加密体系和哈希函数原理，让我们继续来聊聊区块链这件事。前面说过区块链就是一个个区块的串联，现在系统当中比如已经有若干区块，那么是谁来增加区块链当中的下一个区块呢？这时候就是所谓的矿工角色出场。这个矿工是一种形象的比喻，等一会儿你就会知道为什么会叫他们为矿工。</p>
<p>这个矿工的主要任务就是不断为比特币的区块链增加新的区块，但他们添加新的区块是有一定的条件的，比特币的系统规定了每一个区块必须有一个区块的头部信息，这个头部信息包含以下一些内容：一个版本号，然后是前一个区块的哈希，即前一个区块的内容计算产生一个256个比特的哈希的结果，还有就是当前区块所包含的所有交易信息的一个哈希，也是256比特。另外还有时间戳和一个难度系数，这个难度系数的概念我等下再说。最后还有一段乱码，或者叫随机数，为什么要有这个随机数呢？</p>
<p>系统里会有这样的规定，并不是所有人都可以轻易地添加新的一个区块，因为这个区块必须满足一个条件，这个区块的这一串头部信息用系统规定的那个哈希函数算出来之后，它的结果也会是一串哈希的结果，但这个哈希的数字的结果必须小于某一个值，就是说它的开头必须有很多很多的0，小于一定的值，它才是一个合法的区块。</p>
<p>前面已经说过了，哈希函数有一个特点，逆运算是非常困难的，并没有一个简单的方法使哈希结果一定是若干个0为开头输出，使我能快速反推出一个特定的输入，这是做不到的。所以这时候，矿工能做能做的方法就是不断的在这样一些确定的信息之后，在最后尝试加入32位的随机数，不断的去尝试。就比如说你可以从00000001这样一个一个往前尝试，直到尝试出某一个恰好的数字，正好使得哈希的输出非常小，达到了系统的要求，这时候这块区块才是一个合法的区块，然后矿工才可以把这个区块广播给系统中的其他用户。</p>
<p>区块链为什么要有这种设定呢？这个设定的主要思想就是为解决每一笔交易的时序问题，时间先后的问题。让这个区块的产生既不能太快，也不能太慢。为什么不能太快？还是前面说的那个双重消费问题，我同时发出两条交易信息，如果有一些交易信息到达了一些矿工，另外一些到另一批矿工那里，如果产生新区块太简单的话，那么很可能就是两条消息同时被处理。一批矿工是先收到我给张三转账的消息，然后他们拼命算出一个新的区块，加到这个链条里；然后另外一些旷工又算出我给李四转账这条交易信息，他们也算出了一个区块，也是很快就几秒。如果大家都是几秒钟就算出来的话，那等于这两条信息又差不多同一时间被广播到整个网络当中，那就跟没有矿工一样了。相当于是我同时把这条两条信息广播到网络里面，还是没有解决时序问题，如果产生区块太简单的话。</p>
<p>但是也不能太难，如果太难，比如说产生一个区块要算一天才能算出来，那就导致这个交易系统实在太麻烦，我发起一笔交易，要到一天之后才能得到确认，那估计没有多少人能够接受这种货币结算方式。</p>
<p>&nbsp;</p>
<p>现在设定的情况是大概平均每十分钟能产生一个新块，十分钟产生一个新块会达到一种什么效果？如果再假设还是有一个坏人做这种双重消费，那两批矿工互相竞争，有一批矿工算我给张三转账的这个交易，计算新的区块。另有一批旷工算我给李四交易，也去计算新的区块，因为差不多要十多分钟才能算出来，就变成两批矿工之间的算力的一个比拼，这时候就应该是比较容易能够区分出两个两组矿工的计算效率。不管哪个矿工，如果第一个矿工先产生下一个区块，然后马上把这个信息广播出去，那第二个矿工，如果他坚持不放弃，还是算完另一笔交易，然后他也把这个信息广播出去，怎么解决这个问题？还是一个少数服从多数的原则，就是说这两条消息比如相差了十几秒钟，每个人都收到了，相当于这个区块链产生了一个分支，也就是收到两条分支了，这时候每个人都会把这两条分支临时的存储一下。</p>
<p>但是因为系统当中还有不断有新的矿工，一旦有某一个分支里面的区块链条比另外一条更长的话，那每个人都会把那个比较短的那条放弃掉，所以整个来说就是算力的一个比拼，更多的算力支持哪一条分支，这条分支就会被大家接受，而另外一条分支就会被丢弃。按照中本聪的说法，这就是所谓CPU面前人人平等，反正有CPU的人都可以参与这种矿工的计算。</p>
<p>这是不受中心化控制，受CPU控制的一套体系来确保交易的可信度。但这个方法有点小的缺陷，其实真正实际运行起来，离去中心化又稍微有点有点偏差。为什么会有偏差呢？这里就要先说一下为什么有人愿意当矿工，你听出来矿工所做的工作其实非常的无趣，而且繁重，就是说他要不停的进行哈希计算，然后看哈希结果是不是足够小，这种运算有什么意义呢？毫无意义吗？但中本聪在这里设定了一个激励机制，当一个新的区块加进系统的时候，算出这个区块的人，这个用户可以在这个区块中增加一条交易信息，说比特币的系统“送我”50块钱，就是他的账户里面会增加50块钱作为计算的奖励。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>还要说明一下，这个50块钱只是整个比特币游戏刚开始的奖励，中本聪这里又设定了另外一个条件，叫每产生21万个比特币之后这个奖励会减半，比如说第21万个比特币在系统中出现的时候，下一个区块的奖励就会减半，就变成25。而实际上已经发生过两次减半，上一次减半是在去年(2016年)的7月份，也就是说你现在作为旷工去进行这种挖矿运算的话，每次挖成功的奖励是12.5个比特币。顺便说一下，比特币是可以拆分，一块比特币可以拆成0.5，完全没有问题，它实际上可以支持到小数点后八位，也就是0.00000001，这才是比特币交易的最小单位，系统奖励也可以小到这样的。</p>
<p>&nbsp;</p>
<p>中本聪在他的那篇论文，网上也可以下载到一篇非常漂亮的11页的论文，他在这个论文里面也阐述了为什么要给矿工奖励，以及为什么每21万个比特币之后奖励要减半这样一个设定。给奖励的原因首先就是激励大家去做矿工，哪怕现在奖励是12.5，这笔奖励也是相当可观的。另外，这个奖励就起到了类似于货币发行的作用，矿工通过他不断的努力，像挖矿一样，从地下挖出来一些新的黄金，然后这个黄金作为货币发行，这就好比挖矿奖励加入整个比特币交易链的池子里面的过程。</p>
<p>比特币刚开始运行的时候有一个所谓的创世纪交易，就是第一条交易，应该就是中本聪本人给自己账户加了若干钱，具体多少钱我没有好好去看，我记得好像他给自己的账户加了50块钱。有第一条区块之后整个系统就可以运行了。</p>
<p>为什么要奖励要定期减半呢？这个减半奖励为了达到一个效果，使得比特币的总数是有限的，也就是不断地减半减半，迟早这个奖励会小于最小交易额，没办法再产生新的奖励了。总数上限是怎么算出来的？这是一个很好的数学问题。前21万个比特币，奖励是50，后面的21万个变成25，然后后面的21万个又变成12.5，你会看到这个总数，比特币的上限就变成21万，去乘以一个括号，里面是50去加50除以2，50÷4…(21000*(50+25+12.5+6.25+...))。后面这括号里面就是一个等比数列，而且公比是小于1的，根据初中的那个公比小于一的数列有一个有限的和，而这个和正好是一百，所以比特币的总数上限就是21万乘100是2100万。其实这是一个粗糙的计算，因为总有那个奖励已经小于最小交易单位的时候，奖励已经不产生了。</p>
<p>中本聪也说了它为什么要给比特币设定一个上限，就是它会达到让人感觉到这个货币不会有通货膨胀的问题。像我们现实当中的钱的话，总有一个通胀的问题，我们其实平时自己也能感觉到物价会不断的上涨，可能就是因为央行又新发了多少的货币。而比特币的上限等于是提前公布给大家，就是两千一百万个，所以中本聪告诉大家这个货币是不会有通胀，因为我已经事先告诉大家这个上限，发行的方法也已经是公开的，所以大家都会有一个比较好的心理预期。</p>
<p>&nbsp;</p>
<p>根据现在的产生区快的速度来看，基本上每四年会发生一次奖励折半，大家也能推算出来。大概到2033年之后，比特币的总数会达到2100万，也就到那时候，就不会再有新的比特币产生。当然这是根据现在参与比特币游戏的人数和算力来估算的。如果有更多的人参与进来更多的人做矿工，那么这个达到上限的年限可能更提前到来。你可能会问如果将来做矿工都没有奖励的，那谁来挖矿呢？从这里又有一个新的设定，叫做交易费，也就说我在声明一条交易的时候我可以同时声明一下，我给产生区块，其实就是背书这条交易的人，给他一定的钱作为回馈。中本聪认为比特币总数到上限的时候，交易或者说对矿工的激励就是要靠交易费来刺激，但那个时间离还比较早，2033年。但现在也有人在担心是不是到那时候没有奖励就没有人做矿工了，这个比特币游戏就玩不下去了，也有这种担心，有各种各样的讨论，我也没办估计到那时候的形势。</p>
<p>另外一点你可能会问，如果参与这个游戏的人太多，就是用太多的人做矿工，使得产生区块速度太快会怎么办。那我前面提到有一个叫难度系数的问题，就是每一个区块里面会一个当前的难度系数，这个难度系数决定了这个区块头的哈希结果需要达到多小才是有效的。这个难度系数是每产生2016块区块的时候会更新一次这个数值，比特币的软件里面写好的。也不知道中本聪怎么会设定2016这个数字，会不会他认为2016年会发生什么事情，但是也没有发生什么，他也没有暴露身份。2016年是去年，反正他是这样设定的。</p>
<p>然后每到2016块新的区块产生的时候，整个系统就会来计算一下，前面这段时间里面平均产生一个新的区块的速度是多少，如果太快了，那就会增加难度系数，如果太慢了，它就会降低难度系数。根据现在每十分钟产生一个新块的速度的话，这个难度系数大约每两个星期会调整一次。每次调整的时候，如果参与的人一下子非常多，这个难度系数就会增加，如果有一批人退出的话，那么这个难度系数就会下降。反正每次调整之后都能保证整个系统差不多是十分钟产生一个新块。然后这个十分钟不会太快，也不算太慢。这是中本聪非常天才的一点，就是他在整个系统还没还没进行实际运转的时候就能考虑到这样一个问题，动态的去调整产生区快的这个速度问题。</p>
<p>这样十分钟产生一个新块也就保证了，你可能在某些网站也看到说你有一笔交易的话，最好等待等待一个时间，比如十分钟之后，你可以看到你的这笔交易被一个新块确认了，然后你再等十分钟。如果你的交易区块，后面再有一个新快，那么你的这个交易就比较保险，而一般推荐等待一个小时，也就是产生六个新块来确认你的那个交易的时候，这时候你可以放心的跟对方进行交易。</p>
<p>为什么会这样说呢？因为每产生一个新快，你要推翻这个新块前面的交易，等于先要推翻最新的一块，才能去推翻前一块的交易。如果已经产生了六块新的区块了，某一个坏人想推翻你的这笔交易，他就要把这个六块新块的数据全部重新计算，然而在他推算的这个过程中，即使它的算力非常强，但是别人已经在每十分钟里面又往那个原先的那个链条后面每十分钟补充一个区块，所以你可想而知那个推翻的难度是非常大，而且这个难度是随着每一个新块的增加呈指数上升，这就是为什么等待的时间越久，你的那个交易会越可靠。</p>
<p>我们现在已经听出来就是整个交易的驱动是靠矿工不断的计算出新的区块来驱动的，而矿工之间是有一定竞争关系的，也就是说谁先产生这个区块，谁就会拿到奖励。而且这个奖励相当可观，所以就产生了所谓的矿场，即某些人就为获得这些奖励购买非常多计算力来去获得竞争当中的优势，而这个矿场是什么样的一个东西呢？</p>
<p>因为很多哈希算法，它的本质其实矩阵计算，而矩阵计算又是显卡芯片，所谓的gpu芯片最擅长的领域。所以就有人这样，他把很多的显卡集中在一起，然后用打造特定的计算机，这个机器专门用来算比特币的哈希结果。如果你的计算力非常强大的话，那么你就可以很轻易的给这比特币区块链中增加新的区块。</p>
<p>那这个矿场会是怎么样呢？，我看到去年纽约时报走访了在中国贵州的一个矿场。为什么会设在贵州，首先你可想而知，电费得便宜，因为运行那么多gpu，耗电量是非常巨大的。另外还有一个就是场地要便宜，如果在上海的话，你恐怕租不起这个房子来开这个矿场。另外一点就是要通风条件，散热条件也好，也就是气温不能太高。另外我觉得贵州还有一个优势，就是它可能离广东比较近，拿到显卡或者IT的设备是比较容易的。在这个矿场里面就是有密密麻麻的那些机架，但这个机架是非常简陋的，其实就是一些铁架子上有密密麻麻的一些电脑的电源，一些主板和gpu插在上面这些东西而且全部都是裸露在外面，因为他们也不需要美观，全部裸露在外面，没有机箱，线也全部裸露在外面，反正它们也不需要美观，主要考虑的是用来散热。</p>
<p>那么多gpu串联在一起，它们的运算能力就会得到非常大的加强，每秒钟可以算出若干G的哈希结果，然后就从当中挑出一最小的那个哈希的结果去作为下一个区块的那个哈希结果。但我想说的是矿场的出现其实是违背了中本聪当初设想的这个“CPU面前人人平等”的这种理念，矿场其实是新的一个中心化，也就是说整个比特币交易的那个链条或多或少已经很大程度上被各种各样的矿厂垄断了，你个人想去做矿工已经肯定是不可能的，因为你的一两台电脑的计算能力跟人家这个成千上万的gpu去比拼的话完全不可比拟，所以这样是等于产生了新的中心化，这也是我觉得目前比特币交易当中一个让人不舒服的地方吧，包括我自己，可能也是我吃不到葡萄说葡萄酸。因为我自己上一段时间研究的时候，我也尝试去做矿工，但完全挖不到。</p>
<p>现在你要做矿工的话，恐怕你要加入所谓的矿池，有很多人就是允许个人把自己的计算力贡献出来，叫大家把各自的计算力合并在一起，然后加入一个池子，叫所谓的矿区。如果我们矿区里面打到新的比特币的话，然后根据大家的计算力按照比例来分成。当然这种分成，你一两台电脑的贡献的比例，是完全没有利润可言，考虑到你的电脑的消耗，包括电的消耗是完全没有不划算的。我自己尝试了一下，我加入一个矿池的话，每小时还是每天只能打出价值0.01美元就是一美分到两美分左右的比特币了，反正这点钱完全抵不上我的电费，还有我的电脑的损耗，所以这完全不划算。可以说这个比特币现在交易是被矿场垄断，所以这又变成了一种新的中心化，这恐怕也是中本聪本人难以预料的一个结果。但现在你也没办法去阻止，本来这就是去中心化理念的东西，所以没有人可以去干预去说你不可以这样做，因为人家确实也贡献了这么大的计算能力，他的投资也是相当大。</p>
<p>我们最后聊一聊比特币交易的一些特点。首先，比特币交易有一个很大特点，就是每一笔交易要有一个或多个输入和或者一个到多个输出。也就是说我一笔钱转出去，我要在我的交易当中声明我这笔钱的来源，是之前的哪些交易的产生的。然后我也可以同时转给很多人。这种多对多的特性就是使得洗钱变得非常容易了，如果有一笔钱变成比特币，然后把比特币拆分成若干份，转给许多人，这个许多人当中可能都有很多是自己的账户，然后再转给许多人。交易可以让警察来追踪或者让任何人来追踪。虽然这些信息都是公开的，但是那么多匿名的账户使得你的这个追踪非常困难，你完全搞不清楚这个钱的流向。</p>
<p>另外一点就是比特币交易的匿名特性，也就是所谓公开信息，就只有一个账户，谁也不知道这个数字背后代表的是谁，所以这两个特点就是让比特币成为一些灰色交易热衷的一个东西。当然，这也是所谓去中心化理念必然会带来的一个副作用。</p>
<p>&nbsp;</p>
<p>另外还有一个就是比特币交易是不可撤销的，你一旦声明了你自己的一笔交易转给某个人，发到网上了，但你反悔了，要赶紧撤销这条消息，这是做不到的，你一旦做了就是不可撤销。</p>
<p>它跟现在现实当中的货币比较有什么样的特点，它有没有可能取代现实的货币呢？我觉得短期内是不可能完全不可能，因为参与比特币交易难度是非常大的，说我前面我花了这么多时间才能把那个比特币的交易原理大致的说清楚，我想你听了之后应该也只能有一个大致的了解，你不真实地参与一下，恐怕还是没有一个切身的体会。</p>
<p>另外一个就是它对参与者的安全意识的要求非常高，就像我前面说过了，你的那个私钥的安全性是非常重要，一旦你的私钥泄露，你什么东西都没了，没有任何地方去申诉。前几年也发生过，有些比特币交易的网站，因为用户把私钥托管到它的网站上，但是它的网站后来被泄露了，这些私钥也被曝光了，这些网站就倒闭了。一旦倒闭之后，用户也没有办法去索赔，因为这笔钱肯定都被各种方法转走到你想不到的地方去了。</p>
<p>另外一点，它跟现实货币比有个明显缺陷，就是线下交易的困难。比特币交易，是必须要有线上有人帮你用新的区块来确认的，而新的区块产生就要十分钟，所以线下交易，如果有需要一手交钱一手交货的场合的话，就很麻烦，你付了十块钱，要买一样东西，然后你要等十分钟才能有一个区块。有时候对方说我还不放心，要等到六个区块，那得等一小时，这样太困难了，就是线下交易难度是非常大。这两点使我觉得它要取代现实货币还是非常困难的。</p>
<p>&nbsp;</p>
<p>当然最重要的一点就是我始终搞不懂这个比特币跟其他真实货币的这个汇率产生机制是怎么样？现在这个汇率是一比特币等于一千美元，这个汇率产生的依据是什么，我完全没有没有概念，我觉得这倒是一个经济学家应该好好研究的一个话题。那比特币也有到低谷的时候，震荡也是非常剧烈的，有段时间一个比特币可能只有三四百美元，但是现在又回到了一千美元。这个震荡的这个依据到底是什么，我是完全搞不懂，希望有经济学家能好好研究一下。如果有哪个经济学家能够很好地预测这种比特币的汇率变动的话，它有可能是可以拿诺贝尔经济学奖的一个成果。这种震荡那么巨大，所以大家参与的风险是非常大的，特别是如果你想用真金白银去交换比特币的话，这个交易风险非常大。</p>
<p>另外如果你让我说的话，我觉得比特币更像一场网络游戏，这是我为什么前面一直用游戏来比喻它，因为它的很多特性就像网游中的一些货币，但是它跟网游中的货币最大的区别就在于“去中心化”，它并不是某个游戏公司来控制的一个货币。</p>
<p>您如果坚持听到现在的话算是赚到了，因为接下来的内容是我今天加入的，算是一个彩蛋，因为<br />
刚刚过去的星期，谷歌公司发布了一条新闻，就是他们找出了世界上第一个使用的SHA-1的碰撞。这个“碰撞”，如果你还记得我前面上一期讲的内容的话，就是说两个不同内容明文，如果产生的哈希的结果是一样的，那就是一个碰撞，但这种碰撞是非常难以发现的，但是谷歌在这个新闻里面公布了两个不一样的pdf文件，如果你把这两个pdf文件下载下来，然后用SHA-1命令去产生它们的哈希结果的话，它们的结果将是一模一样的。这是密码学界的一个非常大的新闻。那你可能会好奇这个新闻对比特币有没有什么影响呢？会不会影响比特币的安全性，我可以告诉大家目前来看或者将来的很长一段时间内对比特币都应该没有什么影响，因为谷歌这次攻击的算法叫SHA-1，就是相当于SHA最初的版本一一第一代的版本，而比特币用的哈希算法叫SHA256，他是属于SHA-2系列，是二代SHA算法中的一种，所以算法本身是不一样的。</p>
<p>另外谷歌这个攻击其实是寻找碰撞，跟哈希值的逆运算还是有很大区别，寻找碰撞，就是说它已先设计出一个文件，找出它的哈希值，然后重新找一个其他的明文，产生同样的哈希。这跟我任意指定一个哈希结果，然后去反算出一个明文，这个两个问题还是有很大的差别的。直接逆运算问题的难度肯定要比找碰撞要难。</p>
<p>如果我们再退一步说，即使有人已经有办法，就是进行这种逆运算了，但是他的这种攻击的时间<br />
效率决定了攻击的有效性。我们前面已经说过现在比特币平均每产生一个区块，需要大概十分钟的时间。那么如果一个攻击者，即使有一个好的算法，只要一台电脑就能就能算出一个非常小的哈希值，那这个算法的效率必须是小于十分钟，否则就没有产生任何攻击效果。</p>
<p>那我们看谷歌的这次找碰撞的这个算法，它用了多少时间计算呢？它给出了一些相当惊人的数字，这次攻击寻找碰撞的攻击他分了两个阶段，第一个阶段是要用CPU来进行计算，如果用单个CPU这种计算需要6500年。第二阶段是用GPU就是图形计算器来进行攻击，如果只用一个GPU，需要计算110年。</p>
<p>谷歌有大量的硬件资源，它投入了成千上万个cpu/gpu计算，它才能把这次攻击缩短到几个月的时间，所以说比特币还是相当安全，因为现在有大量的矿工的使效率能够维持在十分钟。即使SH256算法有人发现了更快的攻击方法，但这个攻击方法如果不能小于十分钟的话，那它其实还是没有对比特币安全性产生太大影响。</p>
<p>再退后一步，即使是将来的研究发展了，然后有更新更快的算法出来了，那么如果在2033年之前没有这种算法没有出现，那么比特币还是安全的，为什么？因为2033年就是差不多是我前面提到过就是比特币的挖矿奖励将为零的那一年。这一年之后，再做矿工的话，系统是不会产生新的比特币奖励了。那时候你的挖矿的激励就是靠每一笔交易里的交易费，但这个交易费是转账者自己来设定的，它可以设定得很低，也就是说到那时候做矿工的话有点像做活雷锋的感觉，即使有人有那个更快的算法，那么，但充其量也就是更方便别人去做活雷锋，那对比特币应该没有什么太大影响。</p>
<p>另外，到那时候，即使这个哈希算法真的是有太严重的漏洞的话，还有一种可能性就是所有参与比特币游戏的人，大家软件一起升级，改用一个其他的哈希算法。那么前面也说过了这个比特币有一种少数服从多数的机制，如果大家多数人都已经换了一个新的算法，愿意把那个自己软件升级，你不升级，你没办法继续参与这个游戏，所以比特币在这方面安全性还是设定的相当好的。</p>
<p>但这并不是说这你在其他场合就应该继续再用这种SHA-1的这个哈希算法，好的方法应该是你现在就应该用SHA二代或者三代的算法。我感觉对比特币来说最大的那个安全的挑战就是这个非对称加密体系，如果非对称加密体系被攻破了，那对比特币肯定是一个灭顶之灾（下一期节目里你会看到，中本聪对这一点也留了一手！），因为这个就等于每个人的账户都已经暴露了，这个才是最有风险的。但是这个非对称加密体系看起来是非常难以攻破的，因为你的攻破了这个加密体系的话，就相当于解决了一个数学上非常难的问题，是非常困难的。</p>
<p>OK今天比特币的话题就聊到这里，希望大家喜欢。下一期，准备跟大家聊聊中本聪的身份，再见。</p>
<p>收听“大老李聊数学”</p>
<p><img class="alignnone size-full wp-image-380" src="https://dalaoliblog.files.wordpress.com/2017/10/ximalaya.png" alt="ximalaya" width="298" height="286" /></p>
<p>订阅“大老李聊数学”</p>
<p><img class="alignnone size-full wp-image-151" src="https://dalaoliblog.files.wordpress.com/2017/09/qrcode_for_gh_130ed4d8263c_344.jpg" alt="qrcode_for_gh_130ed4d8263c_344" width="344" height="344" /></p>
</div><p><a href="/2017/11/15/e6-af-94-e7-89-b9-e5-b8-81-e5-8e-9f-e7-90-86-e6-b5-85-e8-af-b4-ef-bc-88-e4-b8-8b-ef-bc-89.html">阅读更多</a></p></div><div class="article__info clearfix"><ul class="right-col menu"><li><i class="fas fa-user"></i> <span>大老李</span></li><li><i class="far fa-calendar-alt"></i> <span>2017年 11月15日</span>
            </li></ul></div><meta itemprop="author" content="大老李"/><meta itemprop="datePublished" content="2017-11-15T12:03:21+00:00"></div>
      </article><article class="item" itemscope itemtype="http://schema.org/BlogPosting"><div class="item__content">
          <header><h2 itemprop="headline" class="item__header"><a href="/2017/11/15/e4-bb-bb-e6-84-8f-e5-a4-a7-e4-b8-8e-e5-85-85-e5-88-86-e5-a4-a7-e8-b0-81-e5-a4-a7-ef-bc-9f-e6-95-b0-e5-ad-a6-e7-94-a8-e8-af-ad-e8-b6-a3-e8-b0-88-ef-bc-882.html">“任意大”与“充分大”谁大？--数学用语趣谈（2）</a></h2></header>
          <div class="item__description"><div class="article__content" itemprop="description articleBody"><p>大家好，我是大老李。这期继续我们的数学用语趣谈。这次讲两个容易理解也经常听到的用语：“任意大”与“充分大”。</p>
<p>先说个“任意大”的例子，比如“有任意大的素数”，这句话的意思就是说你无论给出一个多大的整数，总会有一个比它更大的素数，因为素数有无限多个。类似还有任意小，比如正数可以是任意小，因为无论你给出怎样的一个正数，总有一个比它更小的正数，比如你就把它除以2。</p>
<p>但是“充分大”与“任意大”并不一样，你不能说“充分大”的整数都是素数，这肯定是不对的。“充分大”往往用来描述一个涉及到“无限”的数列或函数，来表达这个数列或函数在自变量取值达到一定程度之后，会持续拥有的性质，往往命题里还有“最终”这两个字。比如这样一个命题: “x充分大之后，函数f(x)的值最终大于0”。</p>
<p>“任意大”和“充分大”概念听上去很简单，但你别小瞧它们的作用。它们在数学里非常重要，因为它们是定义所谓“极限”概念的基础。而“极限”的定义，又是整个微积分的基础。这里历史上有段公案，叫所谓“第二次数学危机”。当初牛顿和莱布尼茨在创立微积分之时，他们经常使用一个概念叫“无穷小量”。这个无穷小量是什么东西，他们两位可没定义清楚。相信学过微积分的人，也都会对这个无穷小量产生过一些顾虑，就是$latex \mathrm{d} x$。这个$latex \mathrm{d} x$看上去像一个变量，可以加减乘，甚至是放在分母上，但经常算到最后它就被忽略了，被丢弃了，老师会说因为这是无穷小啊，跟0没区别。但你前面怎么又把它做运算呢，相信很多人有过这种困惑。历史上有一个英国大主教，贝克莱就于公开反对过无穷小量的概念，他在1743年发表的一篇文章里写：“无穷小量是消失了的量的鬼魂……能消化得了二阶、三阶流数的人，是不会因吞食了神学论点就呕吐的。”这话虽然有点尖酸刻薄，但是他的攻击不是没有道理。这个“无穷小量”像一个幽灵一样，是当时数学基础上的缺陷，导致了第二次数学危机。</p>
<p>这次危机一直到柯西，维尔斯塔拉斯等人确立的极限的概念才解决。而极限概念的一般表述形式就是当自变量充分大后，一个函数值与某个定值之间的差可以是任意小。所以，基本上可以说所有的微积分表达式，你把它展开后用语言来描述话，都是当xxx充分大后，xxx与xxx的差是任意小。所以你看“充分大”和“任意大或小”的概念是不是很重要！</p>
<p>那我们再看看有关这两个关键字的命题，其中最出名的莫过于哥德巴赫猜想。哥德巴赫猜想大家想必熟知，就是任何一个偶数都能表示成两个素数之和。而对哥德巴赫猜想的每一次逼近，你会看到数学家解决的都是“当x充分大”之后，任何一个偶数都能表示成什么样的形式。像我小时候，第一次听到我国数学家陈景润证明了所谓”1+2“命题，就是对“充分大的偶数，都能表示成一个素数加两个素数之积”。当时还在读小学的我还奇怪，为啥说“充分大”，因为我自己计算12就等于3+3*3嘛，为啥不说大于12的偶数，就能表示成1个素数加2个素数之积。那只能说我当时太年幼无知，其实陈景润当时自己都不能确定这个偶数的下限，所以只能说“充分大”，足见哥德巴赫猜想困难。</p>
<p>再看看所谓“弱歌德巴赫猜想”证明，更是体现了前赴后继的，薪火相传的精神。这个“弱歌德巴赫猜想”是这么说的，“任何大于7的<a href="https://zh.wikipedia.org/wiki/%E5%A5%87%E6%95%B0">奇数</a>都可以表示为三个奇<a href="https://zh.wikipedia.org/wiki/%E7%B4%A0%E6%95%B0">素数</a>之和”。比如9=3+3+3。很明显它是“歌德巴赫猜想”的推论，所以我们叫它“弱歌德巴赫猜想”。这个弱哥德巴赫猜想的第一次大突破是1937年，苏联数学家伊萬·維諾格拉多夫证明了“弱哥德巴赫猜想”对“充分大”的奇数是正确的，你看“充分大”来了。但是跟陈景润一样，他不能确定这个“充分大”的下限，但这是从无限到有限的一次突破，所以这绝对是一次质的飞跃。两年后，他的学生，确定了一个下限，这就是$latex 3^{14348901}$。虽然大的吓人，但是从不知道下限，到知道一个很大的下限，这也是一次很大的突破。</p>
<p>在之后要推到1997年，四位数学家有一个戏剧性的证明，在广义黎曼假设成立的条件下，弱哥德巴赫猜想对充分大的奇数成立，这个充分大的下限是$latex 10^{20}$。然后他们用电脑验证了一下$latex 10^{20}$以下的所有奇数，都符合弱哥德巴赫猜想。所以他们等于证明了在广义黎曼假设成立的条件下，弱哥德巴赫猜想成立。但问题是他们的证明是依赖于广义黎曼假设，但黎曼假设的证明目前看还是遥遥无期。</p>
<p>再到2002年，两位香港大学的数学家把下限缩小到大约$latex 2*10^{1364}$，这个下限是不依赖其他命题的，但是可惜还是太大，比这个下限小的奇数还是多到无法用计算机来验证。</p>
<p>直到2013年，法国国家科学研究院的研究员哈洛德·賀歐夫各特，发表了两篇论文，终于彻底解决这个问题。他首先综合使用了一些传统方法，将“充分大”的下限缩小到$latex 10^{30}$左右，再把$latex 10^{30}$以下的奇数全都用计算机验证一遍，终于完整证明弱哥德巴赫猜想。</p>
<p>看完这个证明过程我最大的感受就是这个问题之难，其次是解决的方法的有点小偷懒。就是把“充分大”降低到“足够小”，虽然这个足够小对人类来说还是太大了，但有了计算机帮助，我们就能用暴力方法去解决它。我相信这种证明方法将来肯定会越来越多，就是用计算机来帮助判定命题一定范围的真假，我前几期聊过的”拉姆齐理论”也是例证之一。</p>
<p>另外让人感叹的就是虽然弱哥德巴赫猜想解决了，但是哥德巴赫猜想本身和黎曼假设还是岿然不动。虽然它们都能推出弱哥德巴赫猜想，但可惜反方向不行。</p>
<p>前面都是“充分大”之后命题成立的例子，其实数学中本来有一些人们认为“充分大”后命题成立的猜想，结果后来发现原来这些命题还有一个“非常大”的反例的例子。 而这其中最惊人的一个例子还是关于素数的。大家都是知道素数的数量一个简单估计，就是前N个自然数中有大约有$latex \frac{N}{\ln{N}}$个，它有一个等价但更精确估计函数，是一个积分形式($latex Li(x)=\int_{2}^{x}\frac{dt}{\ln{t}}$)，这个积分具体形式不重要，关键是有好事者把这个估计函数和实际素数的数量进行了比较，发现直到几千上万后，实际素数的数量确实越来接近估计函数的估计，但总是少于估计函数。于是，就有人猜想，对所有的自然数N，总是实际数量要小于这个估计函数。</p>
<p>但是，在1914年，与哈代并称剑桥双雄的李特伍德证明，不对，肯定有一个N，使得N以内的素数数量会多于这个估计函数，只是这个N太大了，人们完全不知道这个转变发生在什么地方。后来李特伍德的学生思古斯，在1933年，他34岁那年证明了，这个N会在小于$latex 10^{10^{10^{34}}}$之内出现，不过前提是黎曼假设正确。然后思古斯又奋斗了22年，到了1955年，他证明了这个N会在小于$latex 10^{10^{10^{964}}}$之内出现，这次他不需要黎曼假设这个前提了，所以这个N比之前的还要大很多，已经大到我无法形容了。这个数字人称思古斯数。现在最新成果已经把思古斯数的范围缩小到$latex e^{728}$左右。当然计算机还是远远不能算出这个数，所以我们至今还是不知道第一个会使得素数数量大于那个估计函数的那N值。</p>
<p>你此时可能回想，那是不是有可能存在一个足够大的N，使得大于N之后的所有自然数，它之前包含的素数都一直大于或小于估计函数值呢？这个思路是很好，只是结论更为惊人，还李特伍德证明了，N之前的素数数量与估计函数之间的大小关系其实会发生无数次转变。也就是这个命题从“充分大”变为了“任意大”，现在可以改为，有任意大的N，使得N以内的素数小于估计函数的估计，也有任意大的N，使得N以内的素数数量大于估计函数的估计。两者不矛盾，因为两者发生无数次大小关系改变，而且第一次转变发生的位置我们不知道，目前发现的状态是在$latex e^{728}$附近，有一次转变，但是不是第一次转变不知道。且$latex 10^{19}$之前没有转变。这些巨大的数字 让我想起了一句名言：“如果数学是上帝留给人类的花园，那素数就是藏在花园里的魔鬼”。</p>
<p>好了，今天有关“充分大”和“任意大”的话题讲完了。另外打个广告，我最近在订阅号中，会将我以前发表过后被下架的有关比特币的节目内容以文字形式发表，欢迎你关注阅读。如果你喜欢我的节目请关注或打赏。另外也欢迎你提供节目话题线索。再见！</p>
<p>收听“大老李聊数学”</p>
<p><img class="alignnone size-full wp-image-380" src="https://dalaoliblog.files.wordpress.com/2017/10/ximalaya.png" alt="ximalaya" width="298" height="286" /></p>
<p>订阅“大老李聊数学”：</p>
<p><img class="alignnone size-full wp-image-151" src="https://dalaoliblog.files.wordpress.com/2017/09/qrcode_for_gh_130ed4d8263c_344.jpg" alt="qrcode_for_gh_130ed4d8263c_344" width="344" height="344" /></p>
</div><p><a href="/2017/11/15/e4-bb-bb-e6-84-8f-e5-a4-a7-e4-b8-8e-e5-85-85-e5-88-86-e5-a4-a7-e8-b0-81-e5-a4-a7-ef-bc-9f-e6-95-b0-e5-ad-a6-e7-94-a8-e8-af-ad-e8-b6-a3-e8-b0-88-ef-bc-882.html">阅读更多</a></p></div><div class="article__info clearfix"><ul class="right-col menu"><li><i class="fas fa-user"></i> <span>大老李</span></li><li><i class="far fa-calendar-alt"></i> <span>2017年 11月15日</span>
            </li></ul></div><meta itemprop="author" content="大老李"/><meta itemprop="datePublished" content="2017-11-15T02:44:36+00:00"></div>
      </article><article class="item" itemscope itemtype="http://schema.org/BlogPosting"><div class="item__content">
          <header><h2 itemprop="headline" class="item__header"><a href="/2017/11/10/e6-af-8f-e5-91-a8-e4-b8-80-e9-a2-98-ef-bc-9a-e4-b8-8d-e5-9d-87-e5-8c-80-e7-a1-ac-e5-b8-81-e5-a6-82-e4-bd-95-e5-85-ac-e5-b9-b3-ef-bc-9f-ef-bc-88-e9-99-84-e4-b8-8a-e5-91-a8-e7-ad-94-e6-a1-88-ef-bc-89.html">每周一题：不均匀硬币如何公平？（附上周答案）</a></h2></header>
          <div class="item__description"><div class="article__content" itemprop="description articleBody"><h1>本周题目：不均匀硬币如何公平？</h1>
<p><strong>冯诺依曼</strong>曾经出过这么一道有趣的题目：你有一枚不均匀的硬币，它掷出去正反面向上的概率不等，你也不知道具体哪面向上的概率高，概率是多少。请问，你能否用这枚硬币产生<strong>50%</strong>的概率事件？或者说，你可以用这枚硬币<strong>公平</strong>的与别人打赌？</p>
<p>要求：只能用投掷硬币的动作，只有一枚这样的硬币，不能使用其他工具。</p>
<p>提示：可以投掷不止一次，别想太复杂。</p>
<hr />
<h1>上期答案：</h1>
<p>上周题目是：</p>
<blockquote><p>你在参加一个电视游戏节目，节目中有一次摇大奖机会，但你要与另两名参与者竞争！游戏规则如下：有一个大转盘，转盘上有20格，每一格标注有5，10，15...，100。每人可以转动一次或两次转盘，你的目标是两次旋转后，转盘停止时（转盘会停在一个随机位置，每个位置机会均等），两个数字相加值尽可能接近100，但是一旦大于100则立即出局（最后若有玩家相等，则再转一次，数字高者胜）。最接近但不超过100的玩家可获得大奖！</p>
<p>你现在抽签后是第一个转动转盘，请问你在第一次转动后，当转盘数字大于多少时，应该放弃第二次转动？假设后面的两个玩家都会采用最佳策略，且他们能看到之前的玩家的数字结果。</p></blockquote>
<p>答案是你第一次转后，如果停留在<strong>70</strong>或更多的位置，你应该放弃转第二次！而65或更少时，你应该再转第二次。</p>
<p>推理过程可以反过来，先看第三个玩家。设他第一次转得的数值是$latex A_3$，而他有机会胜出的最小数值是$latex X_3$。$latex X_3$等于前两个玩家中的最高得分玩家的数字（考虑到打平也有机会胜出）。类似的，我们定义有$latex A_1$, $latex X_1$, $latex A_2$, $latex X_2$。</p>
<p>第三个玩家第一次转完的得分是$latex A_3$。如果$latex A_3&gt;X_3$，则他会停下来，因为他确信他获胜。如果$latex A_3=X_3$，他会考虑他与几个玩家打平。如果他与一个玩家打平，且$latex A_3\leq50$，则他会再转一次，因为这样他取胜的概率要比与另一个玩家再加转一次对决的50%胜率高。类似，如果他与两个玩家打平，则加赛一次的胜率是1/3，所以他会在$latex A_3\leq65$的情况下，再转一次。</p>
<p>以上我们知道了第三个玩家的最佳策略，再看第二个玩家。第二个玩家第一次转完的得分是$latex A_2$，$latex X_2$等于第一个玩家达到的分数。如果$latex A_2&lt;X_2$，他会选择再转，因为别无选择。如果$latex A_2=X_2$，则当$latex A_2\leq65$时，他会选择再转。因为此时他有一个机会赢第一个玩家，且不让第三个玩家有太明显优势（请参考第三个玩家的策略）。如果是$latex A_2&gt;X_2$，则他确实需要权衡一下了。因为他已经赢了第一个玩家，但也不能过早放弃，让第三个玩家太有优势。有人用pyhton编程（代码：http://t.cn/Rl19VJN）使用决策树算法计算出，此时当$latex A_2&lt;55$时，第二个玩家应该收手不转（完整计算结果：http://t.cn/Rl19eKN）。</p>
<p>再看第一个玩家。他第一次转完的数字是$latex A_1$。他无从知道多大的数字能赢。此情形下，$latex X_1=0$，且总有$latex A_1&gt;X_1$。但是他已经知道第二第三个玩家的策略，我们可以编程用决策树解决各种情况下的决策（完整分析http://t.cn/Rl1piw3），最终可算得$latex A_1&lt;70$时玩家应该再转一次！</p>
<p>有人就最优策略和实际实验结果（此题原型是国外一电视娱乐节目），发现真实情况下（完整论文：http://t.cn/Rl1OOBu），人有各种各样的偏见，导致该转的时候不转，不该转的时候又多转一次！可见学好数学和编程多重要！</p>
<p>下周再见：</p>
<p>收听“大老李聊数学”音频                                        关注“大老李聊数学”</p>
<p>[gallery ids="380,151" columns="2"]</p>
<p>&nbsp;</p>
</div><p><a href="/2017/11/10/e6-af-8f-e5-91-a8-e4-b8-80-e9-a2-98-ef-bc-9a-e4-b8-8d-e5-9d-87-e5-8c-80-e7-a1-ac-e5-b8-81-e5-a6-82-e4-bd-95-e5-85-ac-e5-b9-b3-ef-bc-9f-ef-bc-88-e9-99-84-e4-b8-8a-e5-91-a8-e7-ad-94-e6-a1-88-ef-bc-89.html">阅读更多</a></p></div><div class="article__info clearfix"><ul class="right-col menu"><li><i class="fas fa-user"></i> <span>大老李</span></li><li><i class="far fa-calendar-alt"></i> <span>2017年 11月10日</span>
            </li></ul></div><meta itemprop="author" content="大老李"/><meta itemprop="datePublished" content="2017-11-10T13:44:45+00:00"></div>
      </article><article class="item" itemscope itemtype="http://schema.org/BlogPosting"><div class="item__content">
          <header><h2 itemprop="headline" class="item__header"><a href="/2017/11/08/e6-af-94-e7-89-b9-e5-b8-81-e5-8e-9f-e7-90-86-e6-b5-85-e8-af-b4-ef-bc-88-e4-b8-8a-ef-bc-89.html">比特币原理浅说（上）</a></h2></header>
          <div class="item__description"><div class="article__content" itemprop="description articleBody"><p>(本文原系本人“喜马拉雅”平台上一期节目，因故下架。现转文字形式发表。因从音频转录为文字，文字风格较为口语化，请谅解。)</p>
<p><img class="alignnone size-full wp-image-588" src="https://dalaoliblog.files.wordpress.com/2017/11/bitcoin.jpeg" alt="bitcoin.jpeg" width="300" height="168" /></p>
<p>大家好，我是大老李。这期我准备跟大家聊聊比特币。为什么要讲比特币，很明显比特币现在这个话题实在太火爆了。我在录节目的这个时刻（2017年2月），一个比特币的汇率达到了一千多美元，就是一个比特币，可以换一千多美元（2017年11月是七千多美元）！每当我看见这个数字，我每次都会感慨，如果早几年，比如说2009年，我就参与这个游戏，多挖几个比特币，那我现在也就不需要在这边给大家讲什么比特币原理了，那也是废话了。</p>
<p>但我要声明一下，我讲这个节目并不是鼓励大家去买什么比特币，我只是从数学原理上跟大家探讨一下比特币这套游戏能够运行的一些原理，当中也用到了很多数学知识，而且我自己本人也很遗憾的告诉大家我至今没有任何的比特币。另外，我在研究比特币的时候，我发现比特币的发明者就是这个叫中本聪的这个人，这个人的身份到目前都是一个迷，关于他的身份有各种各样的猜测说法，过去几年也发生过大大小小的一些新闻事件，这些故事相当精彩，简直可以堪比一场谍战剧，所以我准备将来跟大家聊聊这个中本聪的身份之谜，但这是下一期了，在讲比特币原理之前，我先要讲一个准备知识，这个准备知识是比特币里面非常重要的一个准备知识，叫做非对称加密体系。<br />
什么叫非对称加密体系？先讲讲什么叫对称加密体系吧。对称交易体系，简而言之就是对一串信息加密和解密用的是同一把密钥。比如说我们可能用过Word软件里面的那个密码功能，如果我的文件有一些敏感信息，需要发给另外一个人，那我会给这个Word文件设置一个密码，然后对方在打开这个这个文件的时候，需要同样的这个密码，正确的输入这个密码才能打开这个我文件。我可以通过打电话或者其他方法告诉对方，你要打开我的文件，需要输入同样的密码，这就是所谓的对称加密体系。也就是说加解密同一把密钥，同一个密码。</p>
<p>&nbsp;</p>
<p>那非对称加密体系是怎么样情况，就是每一个人会产生两把密钥，一个叫做公钥，一个叫私钥。所谓公钥就是公共的公，公钥是公开的，顾名思义，就是你可以随意分发给网络上的任何其他人，但这个私钥匙是严格保密的。别人要给你发加密信息怎么办，就是别人用你的公钥把信息进行加密，然后把这个信息发给你，你收到这个信息之后，你就可以用自己的私钥去对它解密，获取这个信息的明文。你要看清它的特点，别人给你发信息，其实是用你的公钥来进行加密，那为什么要搞这种非对称加密体系呢？</p>
<p>刚才那种对称加密体系，有一个比较明显的缺陷，加解密同一把密钥，我这个密钥必须要设法告诉别人，那我这个告诉别人的过程，比如说不管是打电话写邮件，我这个密码就有可能就在这个过程中被泄露了。而非对称加密体系就没有这个问题，别人是用我的公钥来加密的，别人可以把加密过的信息非常放心的，放在网络上的任何地方，给网上所有人去看，没有任何问题，因为只有私钥的人才能去解密这个信息，还原出这个信息的内容。因为加解密使用不一样密钥，所以它被称为非对称加密体系。<br />
在非对称加密体系中公钥和私钥是一一对应的，很明显通过公钥是肯定无法计算出私钥的，否则这个加密体系就不成立了。那通过私钥能不能计算出公钥，这个问题就不是很要紧了。有些非对称加密的方法是私钥算不出公钥，但有些是可以算出公钥，但这个不要紧，要紧的就是通过公钥是算不出私钥的。</p>
<p>另外有一个有趣的特点，其实私钥也是可以用来加密的，我用我自己的私钥也可以对一段信息进行加密，任何人用我的公钥可以把这段信息还原，还原出它的明文。那你会说这有什么用呢？我加密一个信息，但是每个人都能还原出它的原文，这有什么作用呢？它有一个非常好的作用，就是它跟我们现实生活中的签名非常相类似。比如说我把这样一段信息，用我的私钥加密，我加密一下：“我欠张三10块钱”，我把这几个字用我的私钥加密，分发到网上，别人用我的公钥对它解密，一看真的确实是还原出“我欠张三10块钱”这几个字，那别人就可以确信这段信息肯定是我的电脑里签名签出来的，就是用我的私钥才能产生的信息，其他任何人都没有办法产生同样的这段加密过的信息。你看这样是不是起到了一个签名的作用，而且比生活中手写的签名更加强力无数倍，因为我连抵赖的资格都没有，因为别人确信只有拥有我的私钥的人才能产生这样一段信息。<br />
而且这段信息还有很强的防篡改的作用，就是说假设有另外一个人李四，李四拿到了我加密过的“我欠张三10块钱”这个加密过的信息，然后李四说，我能不能修改一下这段文字，产生另外一段加密的文字，文字还原出来变成“我欠李四10块钱”。那可以很明确的告诉你，李四肯定是做不到的，或者说他要做到这一点需要几百年的时间才能尝试出来，所以我很放心。<br />
这就是非对称加密体系中另一个很有用的作用，也是在比特币里面经常用到的, 就是签名的作用。就是说我能产生一段信息，这段信息能使得所有网络上的所有人确信是某一个特定的人才能产生的信息，这就是俗称的签名。</p>
<p>然后大家要理解比特币的话，要牢记一个比特币的中心设计理念，就是所谓的“去中心化”四个字，什么是中心化？你可以想象一下我们现实中的货币，这些货币都是以国家的名义进行发行，然后用国家的信用来担保，这个货币的发行以及它的一些使用的政策，都是一个国家政府的名义来进行操作的，这都是中心化的。而比特币的设计理念就是要去中心化，就是说这个货币没有任何一个中心的人，中心的组织能够控制它，去操作它的一个东西。为什么会有这样一个东西？其实从网络一诞生就有很多那种理想主义者，觉得通过网络所有的人能够平等的交往，所以他们觉得能不能发明一种数字化的货币，也不需要任何人来管理，就是它自己运转起来，这种想法是很吸引人的，但是难度也是非常大的，那就让我们来看看比特币是怎么克服一些技术上的困难。</p>
<p>首先第一个要解决的问题就是身份验证问题，就是说某一笔钱到底是属于谁的，怎么确定这个拥有者的身份？正好我前面已经提过了，非对称加密体系里面有公钥，这个东西就是公共的钥匙，这个公钥用做身份验证就是很自然而然的一件事情。因为这个公钥可以完全放心的公开，在网上发布给每一个人，你对你的账户的那个所有的操作很明显就是靠你的私钥来保证，你必须拥有私钥你才能对你的账户进行操作。所以大家请记住，如果你要参与比特币这个游戏的时候，你对你的私钥必须做到非常严格的保护，因为私钥一旦被泄露，你的账户等于是完全公开给别人，你也没有办法像现实中，你还可以打电话给银行说我要冻结我的账户，你在比特币里面完全没有这种说法，别人拿到你的私钥，他就可以立即对你的账户进行任何操作，也没有办法冻结，也没有什么所谓的挂失，或者我要重置一下密码，都没有这些东西。就是说所有的一切都是靠私钥来确定，这就是身份验证的问题，就这样解决了。</p>
<p>第二个问题就是账户信息，也就是说谁某一个账户拥有多少钱，这个信息到底存在哪里。既然比特币的设计理念是去中心化，那么这个账户信息只存在一个或者几个人的电脑里就不太合适，<br />
所以按中本聪的很天才的想法，就让所有人都有所有人的账户信息。你会说你这样不是没有隐私权了，我一眼就能看出某个账户有这么多比特币，某个账户是很有钱的人。但这完全没有关系，因为每个人公开在网上信息只是一串公钥，就是一串数字而已，这个公钥背后是是谁，完全不知道！只要你不主动主动去说这个账户是我的，那别人是没办法知道你的。所以所有人的账户信息是存在每一个人的电脑上。<br />
那你又会说如果有一个“坏人”，或者说我对我自己的账户进行修改。明明我的账户本来是十块钱，我偷偷的在自己电脑上改，我在电脑上把自己的账户改成一百块钱。但这样的修改是没有用的，因为每个人的机器上都有账户信息，如果你自己一个人修改了，你跟别人的电脑上账本对不上，那你就没办法继续参与这个游戏了。简单而言，也就是说这个比特币游戏有一个叫少数服从多数的原则，你的修改如果得不到多数人的认同，你就没办法继续参与这个游戏，你的数据跟别人保持一样，你才能继续玩下去这个游戏，关于比特币如何存储账户信息就这样解决。<br />
接下来一个问题就是要解决转账问题，转账问题就是说我怎么能够把我个人的账户里的钱转到另一个人的账户，很显然我在发起一条转账信息的时候，你会想那我就向所有参与这个比特币游戏的人广播出去，比如说我向张三转一个比特币，那我就把这条消息广播给所有人，然后所有人接收到这个消息的时候，就找到他自己本地电脑上我的账户，把我的账户减掉一个比特币，然后把<br />
张三的账户加入一个比特币，这样就解决了这个问题，而且很显然我这个转账这个信息必须是我进行签名的，这样别人就不能仿冒我，伪造一条转账的信息。<br />
听上去好像这个问题很简单，但其实这里还有一个非常大的陷阱。比如设想这种情况，假设我的账户里只有一块钱，然后我准备两台电脑，在第一台电脑上我准备一条信息，叫“我给张三转一块钱”，然后我在另外一台电脑上准备另一条信息，我给”李四转一块钱“。然后我两台电脑同时按回车，两条信息差不多同一时刻发出去，其他人接到我的这两个信息一看都是从我的账户里转出去，但一个是转给张三一块钱，另一条转给李四一块钱。但是再一看我的账户里总共只有一块钱，然后这样就不行了吗？这两条信息里面必定只能有一条被接受，另外一条不能被接受。这个问题怎么解决？这个问题也是所有数字化虚拟货币要解决的，可以说是唯一一个，而且是最重大的一个技术难题，叫所谓的double spending，中文翻译可以叫“双重使用”的问题。就是我同一份钱，我用两次。怎么能够防止这种情况的发生？<br />
你很自然地想到那我可以根据先来后到的原则吗？即使你发两条信息，你是同时按回车的，但是我接到两个信息里面总是有一个先来后到的，那么我总是直接接受先到的这条信息。比如说我先收到“我转给张三”这条信息，那么就视为接受这条信息，然后“我转账给李四”，这条信息是后来的，但是那时候你的账户已经被已经是零元了，那我就不能接受这条转账。<br />
但这样有一个问题在，你现在回到这个比特币设计的理念，去中心化，也就是说网络上有无数的人，参与这个游戏的人都是平等的来接收到这两条信息。但是网络的状态又是千变万化，可能对你来说，你是先收到“我转账给张三”的这条信息，但有其他人的电脑有可能先收到“转账给李四”的那条信息，这是很自然的很可能发生的，那你说这个这种情况怎么处理呢？到底听从谁的电脑呢，这是一个很困难的问题。</p>
<p>历史上在比特币之前，有人提出一种设想，就是每个人在转账之前，他必须同时把转账的这个需求发送到某一个公共的论坛上，也就是说我要在这个论坛上留下同样一条信息，“转账张三一块钱”。所有人在接收到转账的需求的时候都要到这个论坛上去核对一下，看一下论坛上有没有同样的这条转账的信息，如果有的话才能够接受，因为这个论坛的帖子肯定会有一个时间戳，也就是有先来后到的，那么如果某一个人同时发了两条，那么对其他所有接收到信息的人，永远以这个论坛上的时间戳来确定转账的先后顺序。这样当然能够能够解决问题了，但是它的缺点就很明显，它违背了比特币这个“去中心化”的这个理念，也就是这个论坛，你到底选择什么样的论坛呢？这个论坛谁来维护？如果这个论坛的信息被黑客攻击，这个论坛万一当机了，那大家这个转账都不能不能操作了，这些问题怎么解决？这个论坛不可避免地成为另外一个中心，所以这就违背了比特币的去中心化的理念。<br />
所以比特币就想了一套新的非常神奇，很有意思的方法来解决这个问题。可能你也听出来了，问题的核心要点，就是要确定两条交易的时间先后顺序，而确定这个时间先后又需要在去中心化的方法下达成。比特币用的方法就是把所有的交易按照时间顺序串成一个链条，这个链条叫做区块链，也是每一个区块都是有一个前面的区块和后面的一个去块，连成一条链条状的东西，而每一个区块都包含了一条或多条交易信息，一旦某一个交易作为某个区块的一部分被加入这个区块链之后，它的合法性或者说它的真实性就得到了一定的确认。但请注意只是一定程度上确认，而这个区块链的设计，又使得当一个区块后面又增加了一个新的区块，后面区块在某种程度上又加强了前一块区块的合法性和真实性。</p>
<p>那这套机制到底是怎么实现的呢？我们就得先讲一个准备知识，叫做Hash函数，中文有时候翻译成哈希，这个哈希函数是怎么样一个东西呢？它的输入参数是一块字符串，或者说一串数字，<br />
它的输出也是一串数字，一般是确定长度的一个数字，这是由这个哈希函数性质来确定。比如说它可以是521位，1024位，2048位，这就是它输出的长度，是事先确定的，但输入的字符串是任意长度的，无所谓，可以是一个字节，一篇文章或者是几张光盘，所有的信息都可以作为它的输入。<br />
哈希函数的输入输出达到一个什么效果？它有两个效果，一个就是单向操作。当有一个输入，这个哈希函数可以很快地算出一个输出。但是逆向操作是非常困难的，就是根据输出的结果要找出它是根据哪个原文算出来的这个结果，这是非常困难的。比如说有一种非常常见的哈希函数叫SHA算法，你的电脑里可能就有一个叫shasum的命令。我就用我的电脑算了一下，比如说“大老李”这三个汉字，在电脑里本质上也是一串数字，所以这三个汉字也是可以产生一个哈希的结果，然后这三个汉字用SHA256算法算出来的哈希的输出是“ac93b7f7b6128099c76f7959acac7a6a71897286fbad7f06eed546923f4fffd8”，一共有64位16进制也就是1024比特，我现在给你看这串输出，我告诉你，这是某一个字符串的SHA256算法的输出。我可以很确信，你没办法在短时间内算出它是怎样一个字符串的输入，但是你可以用电脑很容易地验证，就是用“大老李”三个字验证，它的输出确实是这样一串字符串，这就是哈希函数的第一个特点，叫单向操作，就是不可逆函数，它的逆操作是非常难操作的，算法时间非常久。<br />
另外一个性质呢叫所谓的抗碰撞，理论上两个不同的字符串，会可能会产生同样的哈希结果，<br />
这个道理很简单，因为它的输入是是任意长度的字符串，可短可长，这就无数种输入，<br />
但它输出却是一个定长的，就是输出输出结果，只有有限种结果。那我们根据鸽笼原理，输入有无穷多可能，输出有限，那你肯定输入跟输出的关系肯定是多对一的，也就是说肯定会有多种<br />
不同的输入会产生同样的输出。</p>
<p>那哈希函数的另外一个特点就是说抗碰撞，我告诉你某一个输入会产生这样的输出，你很难找出<br />
两个不同的输入都能产生同样的输出。比如说我刚才告诉你我已经告诉你“大老李”的那个SH256的速度这样一串数字，那你能不能再找出另外其他一种字符串也能产生这样一个输出呢？<br />
虽然理论上讲肯定会有无数种可能输入，这种可能都能产生同样的输出，但是你还是没办法在短<br />
短时间内算出这样的字符串，这就是所谓的抗碰撞。如果两个字符串或者两个数字两个输入的那个二进制输入它的输出是一样的哈希输出是一样的，我们就是说它们是碰撞了。<br />
<img class="alignnone size-full wp-image-590" src="https://dalaoliblog.files.wordpress.com/2017/11/collision.png" alt="Collision.png" width="290" height="205" /></p>
<p>但哈希函数的一个特点要求就是抗碰撞，凡是满足这种，一个是单向单向操作，一个是抗碰撞的算法函数会经常被作为哈希函数。那哈希函数有什么用？一个最常见的用途就是对明文信息的校验，比如说我有一个很大的软件放在网上供你下载，它可能是一个Linux操作系统，一个光盘的镜像，它可能有几个G，那你下载下来的时候，当然是希望你下载下来的东西跟我的原来的内容是一模一样的，那我通常会在网站上再给告诉你，你下载出来的时候，这个光盘的镜像用哈希校验一下它的输出结果会是怎样一个结果，那你下载下来之后在本机跑一下ShaSum，你就可以验证一下你下载下来的文件的哈希的输出跟我网站上公布的输出是不是一样的？如果是一样的，那你肯定很确信的。你下载的这个镜像没有损坏，而且没有遭到别人的恶意篡改。你这时候可能会想想我前面不是说过那个私钥公钥体系吗？如果我如果怕呃篡改或者需要校验的话，为什么我不是把那个光盘镜像用我的私钥进行加密，然后供用户下载，用户先用公钥解密，如果能够正常解密，那这个信息肯定是正确的，而且是未经篡改。</p>
<p>那这个这时候哈希其实就比私钥公钥这种方法有两个好处，一个是使用公钥私钥体系是有点麻烦的，因为我需要让用户要下载到我的公钥，那不是每个用户都会知道加解密的那个操作。那个SHA校验或者哈希的校验现在主流操作系统都有了，而且这个命令是相当简单。另外一个更重要的区别，一般来说非对称加密体系的，不管是用公钥还是用私钥加密一个信息，都会使这个<br />
加密的信息量要翻倍。也就是说假设明文信息是一个G，你加密完，你看这个信息就可能变成两个G了，这就大大增加了这个开销，所以这是很不方便的。所以这就是哈希函数用做校验和防篡改的作用，</p>
<p>另外一个可能更常用这种作用的就是密码存储，你有没有想过就是说你在任何一个网站上<br />
注册，然后你肯定要设定一个密码，你可能以为对方网站会直接把你的密码密码存储在他的服务器上，但其实那样应该不是正常的网站。正常的网站，就不应该把用户的密码作为明文存储起来，而它肯定是把密码用某个哈希函数处理，然后把这个哈希输出的结果存储起来，为什么要这样存储起来呢？</p>
<p>首先，用这种方法还是可以作为用户信息的验证没有问题，你下次登录的时候你输入你的密码，网站同样把你的函数用它设定的那个哈希函数进行一次，进行转换，然后再把转换的结果跟它的数据库里面存储的结果进行比较，如果是一致的话，那么他就认为你输入的密码是正确的，这样做最大的好处呢，就是防泄漏了，因为前面说过这个哈希函数的逆向计算是非常困难，所以即使我的网站里面存储的这个密码被泄露了，被黑客偷走了，那他偷到的也是一串哈希的输出，<br />
那至少这增加了黑客的难度，他要通过这个哈希的输出反推出你的密码是很困难的。这时候你也看出这个防碰撞的重要性，也就是黑客其实拿到哈希输出的话，它并不需要准确的反算出你的你的密码的原文，它只要找出任何一个原文能够产生同样的哈希输出就可以。如果如果一个哈希函数它的没有反碰撞的能力的话，那么黑客有可能就比较快的能够找到找到了他的原文，这也是不可以的。</p>
<p>所以如果有时候我注册一个网站，我的我的邮箱会收到一份邮件，他会告诉我欢迎你来注册，你的你的用户名是什么，你的密码是什么，如果这时候它告诉它在这个邮件里还能显示我的密码原文，那我就会感到非常恐怖，因为我知道这个网站肯定没不是用用哈希函数来存储我的密码，而是把我的密码原文存储在他的网站上，这是非常非常危险的操作，所以这种网站我一旦出现的话，我肯定不会用我常用的密码，我会肯定只能用一个我临时的密码随便应付一下，或者我根本不敢用他的这个网站。<br />
另外顺便说一下，有很多“坏人”，这个“坏人”要打引号。就是有这样这样一帮人，他们会把一些用户常用的密码常用的哈希函数全部去算一遍，比如说多少位以内的字母组合，然后全部常用的哈希函数算一遍，然后存储在数据库里面，然后做一个索引，这样他一旦偷到某个网站的数据库啊信息，然后发现里面的密码的那个哈希函数用的正好是他已经用过的那种，如果你的那个密码又是它常用的所谓的弱密码的话，那么它们就能通过这个数据库很快的查出来你的那个密码的原文，这是非常常见的一个黑客攻击的手段，所以这也提醒我们在设置密码的时候不能设置的过于简单，然后节目到现在这一期时间长度也差不多了，那么我们下半期会继续讲比特币是如何利用哈希函数来实现区块链的，</p>
<p>敬请期待，再见。</p>
<p>收听“大老李聊数学”：</p>
<p><img class="alignnone size-full wp-image-380" src="https://dalaoliblog.files.wordpress.com/2017/10/ximalaya.png" alt="ximalaya" width="298" height="286" /></p>
<p>“大老李聊数学”订阅号：</p>
<p><img class="alignnone size-full wp-image-151" src="https://dalaoliblog.files.wordpress.com/2017/09/qrcode_for_gh_130ed4d8263c_344.jpg" alt="qrcode_for_gh_130ed4d8263c_344" width="344" height="344" /></p>
</div><p><a href="/2017/11/08/e6-af-94-e7-89-b9-e5-b8-81-e5-8e-9f-e7-90-86-e6-b5-85-e8-af-b4-ef-bc-88-e4-b8-8a-ef-bc-89.html">阅读更多</a></p></div><div class="article__info clearfix"><ul class="right-col menu"><li><i class="fas fa-user"></i> <span>大老李</span></li><li><i class="far fa-calendar-alt"></i> <span>2017年 11月08日</span>
            </li></ul></div><meta itemprop="author" content="大老李"/><meta itemprop="datePublished" content="2017-11-08T12:43:24+00:00"></div>
      </article><article class="item" itemscope itemtype="http://schema.org/BlogPosting"><div class="item__content">
          <header><h2 itemprop="headline" class="item__header"><a href="/2017/11/07/e9-9a-8f-e6-9c-ba-e6-95-b0-e4-b8-ad-e9-94-99-e8-af-af-e5-81-87-e8-ae-be-e4-bb-8e-e6-9c-ac-e7-a6-8f-e7-89-b9-e5-ae-9a-e5-be-8b-e5-88-b0-e5-8f-8c-e4-bf-a1.html">“随机”数中错误假设--从“本福特定律”到“双信封悖论”</a></h2></header>
          <div class="item__description"><div class="article__content" itemprop="description articleBody"><p><img class="alignnone size-full wp-image-580" src="https://dalaoliblog.files.wordpress.com/2017/11/2000px-rozklad_benforda.png" alt="2000px-Rozklad_benforda.png" width="2000" height="2000" /></p>
<p>大家好，我是大老李。今天讲个轻松的话题，正好前几天听到我很喜欢的“旭岽叨科学”节目中提到了本福特定律，提到了很有意思的一些反直觉的概率现象，我就随后研究了一下“本福特”定律，有点思考跟大家分享一下。其实这期节目真的是基本不需要啥数学基础的，因为本福特定律反映的更多的是社会或自然现象。</p>
<p>先重复一下什么是本福特定律，很简单，就是一个叫弗兰克.本福特的物理学家在1938年发现身边的很多随处可见的一批数字的分布是有规律的，比如我们看看当初本福特在其发表的文章中举过的例子：335条河流的长度或区域的面积，这个区域猜想可大到国家，小到一个学校这种；3259条人口数据，这里也没有尺度，不过既然多达3000多条，那肯定也是有国家有城市有乡村不同大小区域的人口数据；104个物理数学常量，100份报纸上出现的数字等等等等。现在问你，以上这些不同类别的数字，尽管单位各不相同，我现在问你，只看数字，以1开头的数字比例有多少，以9开头的又有多少？可能你的第一感就是这两者应该都一样的，应该都是1/9，也就是11%左右。但是本福特发现，这些数字中是1开头的数字特别多，达到30%，然后逐步减少，到9开头的数字特别少，大概只有4.5%了，这是不是有点意外？而这个数字分布规律后来就被称为本福特定律。</p>
<p>而关于数字为什么会这么分布倒是一个很有意思的话题，有很多种解释，其实概率分布为什么会是这样是很难证明。我个人看了很多解释，但归根结底，就是两种原因造成的。一种是有关概率分布的范围。当我们在评估一个概率事件的时候，我们往往忽略的这个概率事件结果的取值范围，其实是对结果的概率分布有影响的。比如搞一个抽奖，如果抽奖号码范围是1-199，那我当然知道1开头的是更多点的。你只有抽奖范围是1-99，那你才可能是1-9开头的中奖号码是均匀的。</p>
<p>取值范围是一个因素，其实还有一个更重要的因素，这就是人们倾向于把随机变量看作均匀分布的，比如那些统计数字听上去像是很随机取值的，比如河流长度，地区人口啊。但其实你多想一下，你猜正态分布都比均匀分布靠谱一些啊，你说是吧。但是人的直觉就是先把这些变量想成均匀分布的。</p>
<p>由此我想到另外一个例子，证明人的直觉是多容易陷入均匀分布，这就是非常著名的“双信封悖论”。这个悖论是这样说的：我给你两个信封，里面都有一些钱，其中一个的信封的钱数目是另一个的两倍。你可以随便选择一个信封，但是在打开前，你有意思更换信封的机会，请问你应不应该更换？乍一听，这不就是算期望值吗，那我们来算一下。如果假设你选定的信封里面的钱数是x，那么另一个信封里的钱要么是x/2，要么是2倍的x，看上去概率均等。那么另一个信封里的钱数，期望值似乎就该是50%乘以x/2加50%乘2x等于四分之x加x等于1.25x! 我手头里的信封的钱是x，那你就应该换另一个信封啊。你是不是已经觉得不对了？因为你换另一个信封的话，那你用同样计算方法就应该换回来啊，那你何必去换信封了？总之你选了哪个信封，似乎另一个信封的期望值就要更高了。那问题到底出在哪里？网上有很多解释，但很多解释都过于复杂，其实归根结底，就是你在计算期望值时不自觉的做了错误的随机变量取值范围和均匀分布的假设。</p>
<p>先看取值范围，首先信封里的钱数目必须是有一个上限的，不是无限的。你可能会说，没必要啊，如果跟我玩的的是比尔.盖茨，他的钱对我来说感觉就是无限的啊。那我们来举例说明下，不管这个上限多高，只要有上限，就会影响结果。比如我现在跟你说，我给你的两个信封，其他不变，但里面钱最多是100块，那你会怎么算呢？我可能会这样想，如果我拿到的钱是在50-100块之间的，那另一个信封只可能是一半了啊，也就是另一个信封的期望值只能是x/2。如果是1-50之间，我用之前的算法，那另一个信封的期望值是1.25x。如果我认为两种情况几率相等的话，那总体期望值就是50%乘x/2加50%乘1.25x=0.875x，那我就是不该换了对不对？那你知道我这样的计算是肯定有问题的，因为理论上另一个信封的期望值应该也是x。但是它足以说明，钱数的上限是对期望值计算有重大影响的。</p>
<p>那我们再看为什么前面的计算还是不对，错就错在我们不自觉的假设了0-50之间钱数的分布是均匀分布的。其实按题意，钱数是无法在这个区间均匀分布的。为方便理解，我们假设钱数都是整数，那你会发现两个信封里的钱的可能状况就是(1, 2)，(2, 4),  (3, 6)... (50, 100)。如果是1-50之间，你拿到是的钱数是奇数，那你必然就应该换另一个信封了，只有当你拿到的信封的钱是1-50且为偶数的话，那你就有一半几率换到2倍的钱，另有一半几率拿一半的钱。所以综合以上，我们大致可以分成三种情况，大于50的不换，而且大于50时，必定是偶数，所以其实是大于50的偶数情况不换，小于50的奇数必须换，小于50的偶数换不换一样。那综合一看，是不是换与不换都一样了？这样双信封悖论不就解决了？这就说明了，人很自然的会假设一个概率事件是均匀分布，但其实不尽然。</p>
<p>本福特定律不是均匀分布，那是什么分布呢，并且又是为什么发生这种情况呢，为什么不是正态分布呢？以上问题，那只能倒猜了。首先数学家先找出了最符合本福特定律的一个分布公式，就是一个含有对数的公式，具体公式我节目不念了，大家可以看节目介绍或关注我的公众号。</p>
<p>[caption id="attachment_573" align="alignnone" width="506"]<img class="alignnone size-full wp-image-573" src="https://dalaoliblog.files.wordpress.com/2017/11/screen-shot-2017-11-05-at-5-36-49-pm.png" alt="Screen Shot 2017-11-05 at 5.36.49 PM" width="506" height="140" /> (10进制数字中，以D开头的数字出现概率)[/caption]</p>
<p>[caption id="attachment_574" align="alignnone" width="426"]<img class="alignnone size-full wp-image-574" src="https://dalaoliblog.files.wordpress.com/2017/11/screen-shot-2017-11-05-at-4-54-58-pm.png" alt="Screen Shot 2017-11-05 at 4.54.58 PM" width="426" height="328" /> 本福特定律中，10进制下，首位数字的出现概率）[/caption]</p>
<p>根据公式，人们找出了一种目前看来最合理的本福特定律产生原因：就是所谓按比例增长的变量，会发生本福特定律。举个例子，比如说人口，如果一个地方人口是1万人，那它要从1万人增加到2万人，那是很困难，因为要增加100%。要从2万人增加到3万人，那就要增加50%，虽然难但是比1万人增加到2万人要简单很多。如果是从9万人增加到10万人，那感觉就容易很多，因为只要再增加11%左右就可以了。这样的话，我们就容易理解城市的人口停留在首位数字为1的时间会最久，而9的时候就最短。有很多事物都符合这种增长规律，比如GDP，我们一般是谈增加的比例，而不是增加的绝对值，因为只有增加的比例值是具有可比性的。所以我也可以很明确讲各个国家的GDP数字的首位值也符合本福特定律。你稍微想一下符合这种性质的数字还是很多的。所谓本福特定律的尺度不变形，就是同一个指标换成不同进制，比如2进制，16进制等等，或者取数字头两位，三位等等，这个性质仍然存在；这种尺度不变性性质用这个按比例增长的理论去解释就很容易会理解了。</p>
<p>但有些数字就不是那么好解释，比如报纸杂志上的数字为什也符合本福特定律？我的一种解释是，报纸上的数字的来源大部分是符合本福特定律的数字，比如人口，面积，经济方面的数字等等，虽然这些数字是来源是随机的，但是来源是比较均匀的取自符合本福特定律的数字，那综合结果就继续能符合本福特定律。</p>
<p>那为什么教科书后面的答案表的数字也符合本福特定律？这个问题就有意思了，虽然我有点怀疑这种说法，但是如果这是事实的话，那我只能说这是心律学范畴的问题了。一种可能的解释是比如60+50=110这样加法题要比60+35=95这样的加法题更容易出现在数学数里。当然这是我瞎猜了，我也很希望有人能认真统计一下各种教科书后面答案的数字，首先看下到底是否符合这一定律。</p>
<p>最不好解释的是所谓常量，数学物理常量。我又看了下本福特统计的104个常量的分布，其实并不太符合本福特定律，1开头的有41%，而最少的其实是6，7，8开头，其中7开头的只有1%，8开头的有2.9%，9开头的倒有10.6%，挺接近平均数了。其实3开头的也有一个低谷，只有4.8%。所以总体分布就是1开头最多，到3很少，4，5开头又多了，6，7，8又很少，9又开始多，所以我不觉得它符合本福特定律。但为什么会这样，那可能是一个无法回答的问题，因为数学物理常量可能都是宇宙的启动参数吧，不是人能解释的。</p>
<p>其实这期在研究本福特定律后的最大感想就是生活中处处有意外的发现，像本福特定律这样规律，并不需要很多数学知识，就是去统计数字，然后从结果里去反推原因。所以各位听友，如果你自己在日常生活中如果能接触到一些特别的数字，不妨把他们搜集起来，做点小统计，看看是不是符合本福特定律，如果不符合的话，是不是有什么规律。说不定会有一些有意思的发现，然后就成为你个人的命名的定律。好了，下期再见！</p>
<p>收听“大老李聊数学”音频节目：</p>
<p><img class="alignnone size-full wp-image-380" src="https://dalaoliblog.files.wordpress.com/2017/10/ximalaya.png" alt="ximalaya" width="298" height="286" /></p>
<p>“大老李聊数学”订阅号：</p>
<p><img class="alignnone size-full wp-image-151" src="https://dalaoliblog.files.wordpress.com/2017/09/qrcode_for_gh_130ed4d8263c_344.jpg" alt="qrcode_for_gh_130ed4d8263c_344" width="344" height="344" /></p>
</div><p><a href="/2017/11/07/e9-9a-8f-e6-9c-ba-e6-95-b0-e4-b8-ad-e9-94-99-e8-af-af-e5-81-87-e8-ae-be-e4-bb-8e-e6-9c-ac-e7-a6-8f-e7-89-b9-e5-ae-9a-e5-be-8b-e5-88-b0-e5-8f-8c-e4-bf-a1.html">阅读更多</a></p></div><div class="article__info clearfix"><ul class="right-col menu"><li><i class="fas fa-user"></i> <span>大老李</span></li><li><i class="far fa-calendar-alt"></i> <span>2017年 11月07日</span>
            </li></ul></div><meta itemprop="author" content="大老李"/><meta itemprop="datePublished" content="2017-11-07T03:43:39+00:00"></div>
      </article></div><div class="pagination"><p>共计 76 篇文章，10 页。</p>
    <div class="pagination__menu">
      <ul class="menu menu--nowrap"><li><a class="button button--secondary button--circle" href="/page7">
            <i class="fas fa-angle-left"></i>
          </a></li><li>
              <a class="button button--secondary button--circle" href="/"><span>1</span></a>
            </li><li><span class="pagination__omit"><i class="fas fa-ellipsis-h"></i></span></li><li>
                  <a class="button button--secondary button--circle" href="/page7"><span>7</span></a>
                </li><li>
              <div class="button button--primary button--circle focus"><span>8</span></div>
            </li><li>
                  <a class="button button--secondary button--circle" href="/page9"><span>9</span></a>
                </li><li>
                  <a class="button button--secondary button--circle" href="/page10"><span>10</span></a>
                </li><li><a class="button button--secondary button--circle" href="/page9">
            <i class="fas fa-angle-right"></i>
          </a></li></ul>
    </div>
  </div></div>
<script>/*(function () {

})();*/</script>

</div></article>
            </div>
          </div></div></div>

      <div class="page__footer">
<div class="footer js-page-footer">
  <div class="main"><aside  itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大老李"><meta itemprop="url" content="https://dalaoli-shuxue.github.io/"><meta itemprop="description" content="爱数学的IT男，兼摇滚中年。"><div class="footer__author-links"><div class="author-links">
  <ul class="menu menu--nowrap menu--inline"><link itemprop="url" href="https://dalaoli-shuxue.github.io/"><li title="给我发邮件。">
      <a class="button button--circle mail-button" itemprop="email" href="mailto:liyouhua@gmail.com" target="_blank">
        <i class="fas fa-envelope"></i>
      </a></ul>
</div>
</div>
    </aside>
    <footer class="site-info"><p class="menu menu--center">
        <span>© 大老李聊数学 2018</span>
        <a type="application/rss+xml" href="/feed.xml">RSS</a>
      </p>
      <p>Powered by <a title="Jekyll is a simple, blog-aware, static site generator." href="http://jekyllrb.com/">Jekyll</a> & <a
        title="TeXt is a succinct theme for blogging." href="https://github.com/kitian616/jekyll-TeXt-theme">TeXt Theme</a>.
      </p>
    </footer>
  </div>
</div></div>
    </div>
  </div><div class="page__search-panel"><div class="search">
  <div class="main">
    <div class="search__header">搜索</div>
    <div class="search-bar">
      <div class="search-box js-search-box">
        <div class="search-box__icon-search"><i class="fas fa-search"></i></div>
        <input type="text" />
        <div class="search-box__icon-clear js-icon-clear">
          <a><i class="fas fa-times"></i></a>
        </div>
      </div>
      <button class="button button--secondary button--pill search__cancel js-search-toggle">
        取消</button>
    </div>
    <div class="search-result js-search-result"></div>
  </div>
</div>

<script>var SOURCES = window.TEXT_VARIABLES.sources;
var PAHTS = window.TEXT_VARIABLES.paths;
window.Lazyload.js([SOURCES.jquery, PAHTS.search_js], function() {
  var searchData = window.TEXT_SEARCH_DATA ? initData(window.TEXT_SEARCH_DATA) : {};

  function memorize(f) {
    var cache = {};
    return function () {
      var key = Array.prototype.join.call(arguments, ',');
      if (key in cache) return cache[key];
      else return cache[key] = f.apply(this, arguments);
    };
  }

  function initData(data) {
    var _data = [], i, j, key, keys, cur;
    keys = Object.keys(data);
    for (i = 0; i < keys.length; i++) {
      key = keys[i], _data[key] = [];
      for (j = 0; j < data[key].length; j++) {
        cur = data[key][j];
        cur.title = window.decodeUrl(cur.title);
        cur.url = window.decodeUrl(cur.url);
        _data[key].push(cur);
      }
    }
    return _data;
  }

  /// search
  function searchByQuery(query) {
    var i, j, key, keys, cur, _title, result = {};
    keys = Object.keys(searchData);
    for (i = 0; i < keys.length; i++) {
      key = keys[i];
      for (j = 0; j < searchData[key].length; j++) {
        cur = searchData[key][j], _title = cur.title;
        if ((result[key] === undefined || result[key] && result[key].length < 4 )
          && _title.toLowerCase().indexOf(query.toLowerCase()) >= 0) {
          if (result[key] === undefined) {
            result[key] = [];
          }
          result[key].push(cur);
        }
      }
    }
    return result;
  }

  var renderHeader = memorize(function(header) {
    return $('<p class="search-result__header">' + header + '</p>');
  });

  var renderItem = function(index, title, url) {
    return $('<li class="search-result__item" data-index="' + index + '"><a class="button" href="' + url + '">' + title + '</a></li>');
  };

  function render(data) {
    if (!data) {
      return null;
    }
    var $root = $('<ul></ul>'), i, j, key, keys, cur, itemIndex = 0;
    keys = Object.keys(data);
    for (i = 0; i < keys.length; i++) {
      key = keys[i];
      $root.append(renderHeader(key));
      for (j = 0; j < data[key].length; j++) {
        cur = data[key][j];
        $root.append(renderItem(itemIndex++, cur.title, cur.url));
      }
    }
    return $root;
  }

  // search box
  var $searchBox = $('.js-search-box');
  var $searchInput = $searchBox.children('input');
  var $searchClear = $searchBox.children('.js-icon-clear');
  var $result = $('.js-search-result'), $resultItems;
  var lastActiveIndex, activeIndex;

  function searchBoxEmpty() {
    $searchBox.removeClass('not-empty'); $result.html(null);
    $resultItems = $('.search-result__item'); activeIndex = 0;
  }

  $searchInput.on('input', window.throttle(function() {
    var val = $(this).val();
    if (val === '' || typeof val !== 'string') {
      searchBoxEmpty();
    } else {
      $searchBox.addClass('not-empty'); $result.html(render(searchByQuery(val)));
      $resultItems = $('.search-result__item'); activeIndex = 0;
      $resultItems.eq(0).addClass('active');
    }
  }, 400));
  $searchInput.on('focus', function() {
    $(this).addClass('focus');
  });
  $searchInput.on('blur', function() {
    $(this).removeClass('focus');
  });
  $searchClear.on('click', function() {
    $searchInput.val(''); searchBoxEmpty();
  });

  // search panel
  var $pageRoot = $('.js-page-root');
  var $searchToggle = $('.js-search-toggle');
  var showSearch = false;

  function closeSearchPanel() {
    $pageRoot.removeClass('show-search-panel');
    $searchInput[0].blur();
    setTimeout(function() {
      $searchInput.val(''); searchBoxEmpty();
      window.pageAsideAffix && window.pageAsideAffix.refresh();
    }, 400);
  }
  function openSearchPanel() {
    $pageRoot.addClass('show-search-panel');
    $searchInput[0].focus();
  }

  // Char Code: 13  Enter, 27  ESC, 37  ⬅, 38  ⬆, 39  ➡, 40  ⬇, 83  S, 191 /
  function isFormElement(e) {
    var tagName = e.target.tagName || e.srcElement.tagName;
    return tagName === 'INPUT' || tagName === 'SELECT' || tagName === 'TEXTAREA';
  }
  function charCodeFilter(e) {
    return e.target === $searchInput[0] && (e.which === 13 || e.which === 27 || e.which === 38 || e.which === 40);
  }

  function updateResultItems() {
    lastActiveIndex >= 0 && $resultItems.eq(lastActiveIndex).removeClass('active');
    activeIndex >= 0 && $resultItems.eq(activeIndex).addClass('active');
  }

  function moveActiveIndex(direction) {
    var itemsCount = $resultItems ? $resultItems.length : 0;
    if (itemsCount > 1) {
      lastActiveIndex = activeIndex;
      if (direction === 'up') {
        activeIndex = (activeIndex - 1 + itemsCount) % itemsCount;
      } else if (direction === 'down') {
        activeIndex = (activeIndex + 1 + itemsCount) % itemsCount;
      }
      updateResultItems();
    }
  }

  $(document).on('keyup', function(e) {
    if (!isFormElement(e) || charCodeFilter(e)) {
      if (e.which === 83 || e.which === 191) {
        showSearch || (showSearch = true, openSearchPanel());
      } else if (e.which ===  27) {
        showSearch && (showSearch = false, closeSearchPanel());
      } else if (e.which === 38) {
        showSearch && moveActiveIndex('up');
      } else if (e.which === 40) {
        showSearch && moveActiveIndex('down');
      } else if (e.which === 13) {
        showSearch && $resultItems && activeIndex >= 0 && $resultItems.eq(activeIndex).children('a')[0].click();
      }
    }
  });

  $result.on('mouseover', '.search-result__item > a', function() {
    var itemIndex = $(this).parent().data('index');
    itemIndex >= 0 && (lastActiveIndex = activeIndex, activeIndex = itemIndex, updateResultItems());
  });

  $searchToggle.on('click', function() {
    showSearch = !showSearch;
    showSearch ? openSearchPanel() : closeSearchPanel();
  });
});</script></div></div>


<script>(function() {
  var SOURCES = window.TEXT_VARIABLES.sources;
  window.Lazyload.js(SOURCES.jquery, function() {
    function scrollToAnchor(anchor, duration, callback) {
      var $root = this;
      $root.animate({ scrollTop: $(anchor).position().top }, duration, function() {
        window.history.replaceState(null, '', window.location.href.split('#')[0] + anchor);
        callback && callback();
      });
    }
    $.fn.scrollToAnchor = scrollToAnchor;
  });
})();(function() {
  var SOURCES = window.TEXT_VARIABLES.sources;
  window.Lazyload.js(SOURCES.jquery, function() {
    var $window = $(window), $root, $scrollTarget, $scroller, $scroll;
    var rootTop, rootLeft, rootHeight, scrollBottom, rootBottomTop;
    var offsetBottom = 0, disabled = false, scrollTarget = window, scroller = 'html, body', scroll = window.document;
    var hasInit = false, isOverallScroller = true, curState;

    function setOptions(options) {
      var _options = options || {};
      _options.offsetBottom && (offsetBottom = _options.offsetBottom);
      _options.scrollTarget && (scrollTarget = _options.scrollTarget);
      _options.scroller && (scroller = _options.scroller);
      _options.scroll && (scroll = _options.scroll);
      _options.disabled !== undefined && (disabled = _options.disabled);
      $scrollTarget = $(scrollTarget);
      $scroller = $(scroller);
      isOverallScroller = window.isOverallScroller($scrollTarget[0]);
      $scroll = $(scroll);
    }
    function initData() {
      top();
      rootHeight = $root.outerHeight();
      rootTop = $root.offset().top + (isOverallScroller ? 0 :  $scrollTarget.scrollTop());
      rootLeft = $root.offset().left;
    }
    function calc(needInitData) {
      needInitData && initData();
      scrollBottom = $scroll.outerHeight() - offsetBottom - rootHeight;
      rootBottomTop = scrollBottom - rootTop;
    }
    function top() {
      if (curState !== 'top') {
        $root.removeClass('fixed').css({
          left: 0,
          top: 0
        });
        curState = 'top';
      }
    }
    function fixed() {
      if (curState !== 'fixed') {
        $root.addClass('fixed').css({
          left: rootLeft + 'px',
          top: 0
        });
        curState = 'fixed';
      }
    }
    function bottom() {
      if (curState !== 'bottom') {
        $root.removeClass('fixed').css({
          left: 0,
          top: rootBottomTop + 'px'
        });
        curState = 'bottom';
      }
    }
    function setState() {
      var scrollTop = $scrollTarget.scrollTop();
      if (scrollTop >= rootTop && scrollTop <= scrollBottom) {
        fixed();
      } else if (scrollTop < rootTop) {
        top();
      } else {
        bottom();
      }
    }
    function init() {
      if(!hasInit) {
        var interval, timeout;
        calc(true); setState();
        // run calc every 100 millisecond
        interval = setInterval(function() {
          calc();
        }, 100);
        timeout = setTimeout(function() {
          clearInterval(interval);
        }, 45000);
        window.pageLoad.then(function() {
          setTimeout(function() {
            clearInterval(interval);
            clearTimeout(timeout);
          }, 3000);
        });
        $scrollTarget.on('scroll', function() {
          disabled || setState();
        });
        $window.on('resize', function() {
          disabled || (calc(true), setState());
        });
        hasInit = true;
      }
    }

    function affix(options) {
      $root = this;
      setOptions(options);
      if (!disabled) {
        init();
      }
      $window.on('resize', window.throttle(function() {
        init();
      }, 200));
      return {
        setOptions: setOptions,
        refresh: function() {
          calc(true); setState();
        }
      };
    }
    $.fn.affix = affix;
  });
})();(function() {
  var SOURCES = window.TEXT_VARIABLES.sources;
  window.Lazyload.js(SOURCES.jquery, function() {
    var $window = $(window), $root, $scrollTarget, $scroller, $tocUl = $('<ul class="toc"></ul>'), $tocLi, $headings, $activeLast, $activeCur;
    var selectors = 'h1,h2,h3', container = 'body', scrollTarget = window, scroller = 'html, body', disabled = false;
    var headingsPos, scrolling = false, rendered = false, hasInit = false;
    function setOptions(options) {
      var _options = options || {};
      _options.selectors && (selectors = _options.selectors);
      _options.container && (container = _options.container);
      _options.scrollTarget && (scrollTarget = _options.scrollTarget);
      _options.scroller && (scroller = _options.scroller);
      _options.disabled !== undefined && (disabled = _options.disabled);
      $headings = $(container).find(selectors);
      $scrollTarget = $(scrollTarget);
      $scroller = $(scroller);
    }
    function calc() {
      headingsPos = [];
      $headings.each(function() {
        headingsPos.push(Math.floor($(this).position().top));
      });
    }
    function setState(element, disabled) {
      var scrollTop = $scrollTarget.scrollTop(), i;
      if (disabled || !headingsPos || headingsPos.length < 1) { return; }
      if (element) {
        $activeCur = element;
      } else {
        for (i = 0; i < headingsPos.length; i++) {
          if (scrollTop >= headingsPos[i]) {
            $activeCur = $tocLi.eq(i);
          } else {
            $activeCur || ($activeCur = $tocLi.eq(i));
            break;
          }
        }
      }
      $activeLast && $activeLast.removeClass('active');
      ($activeLast = $activeCur).addClass('active');
    }
    function render() {
      if(!rendered) {
        $root.append($tocUl);
        $headings.each(function() {
          var $this = $(this);
          $tocUl.append($('<li></li>').addClass('toc-' + $this.prop('tagName').toLowerCase())
            .append($('<a></a>').text($this.text()).attr('href', '#' + $this.prop('id'))));
        });
        $tocLi = $tocUl.children('li');
        $tocUl.on('click', 'a', function(e) {
          e.preventDefault();
          var $this = $(this);
          scrolling = true;
          setState($this.parent());
          $scroller.scrollToAnchor($this.attr('href'), 400, function() {
            scrolling = false;
          });
        });
      }
      rendered = true;
    }
    function init() {
      var interval, timeout;
      if(!hasInit) {
        render(); calc(); setState(null, scrolling);
        // run calc every 100 millisecond
        interval = setInterval(function() {
          calc();
        }, 100);
        timeout = setTimeout(function() {
          clearInterval(interval);
        }, 45000);
        window.pageLoad.then(function() {
          setTimeout(function() {
            clearInterval(interval);
            clearTimeout(timeout);
          }, 3000);
        });
        $scrollTarget.on('scroll', function() {
          disabled || setState(null, scrolling);
        });
        $window.on('resize', window.throttle(function() {
          if (!disabled) {
            render(); calc(); setState(null, scrolling);
          }
        }, 100));
      }
      hasInit = true;
    }
    function toc(options) {
      $root = this;
      setOptions(options);
      if (!disabled) {
        init();
      }
      $window.on('resize', window.throttle(function() {
        init();
      }, 200));
      return {
        setOptions: setOptions
      };
    }
    $.fn.toc = toc;
  });
})();/*(function () {

})();*/</script>
    </div>
    <script>(function () {
  var $root = document.getElementsByClassName('root')[0];
  if (window.hasEvent('touchstart')) {
    $root.dataset.isTouch = true;
    document.addEventListener('touchstart', function(){}, false);
  }
})();</script>
  </body>
</html>