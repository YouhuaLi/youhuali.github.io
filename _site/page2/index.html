<!DOCTYPE html><html lang="zh">
  <head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no"><title>主页 - 大老李聊数学</title>

<meta name="description" content="基本都是“大老李聊数学”音频节目讲稿 继续以半专业的好奇心解读专业的数学知识，给您轻松愉快的收听体验，带来更多好玩有意思的数学内容。 用收听的方式理解数学，跟您聊聊公理，悖论，数论，函数等各种数学相关话题。还会不定期汇报数学界最新成果和新闻。
">
<link rel="canonical" href="http://localhost:4000/page2/"><link rel="alternate" type="application/rss+xml" title="大老李聊数学" href="/feed.xml">
<!-- begin favicon --><link rel="apple-touch-icon" sizes="180x180" href="/assets/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicon-16x16.png"><link rel="manifest" href="/assets/site.webmanifest"><link rel="mask-icon" href="/assets/safari-pinned-tab.svg" color="#fc4d50"><link rel="shortcut icon" href="/assets/favicon.ico">

<meta name="msapplication-TileColor" content="#ffc40d"><meta name="msapplication-config" content="/assets/browserconfig.xml">

<meta name="theme-color" content="#ffffff">
<!-- end favicon --><link rel="stylesheet" href="/assets/css/main.css"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" >
<script>(function() {
  window.isArray = function(val) {
    return Object.prototype.toString.call(val) === '[object Array]';
  };
  window.isString = function(val) {
    return typeof val === 'string';
  };

  window.decodeUrl = function(str) {
    return str ? decodeURIComponent(str.replace(/\+/g, '%20')) : '';
  };


  window.hasEvent = function(event) {
    return 'on'.concat(event) in window.document;
  };

  window.isOverallScroller = function(node) {
    return node === document.documentElement || node === document.body || node === window;
  };

  window.pageLoad = (function () {
    var loaded = false, cbs = [];
    window.addEventListener('load', function () {
      var i, cb; loaded = true;
      if (cbs.length > 0) {
        for (i = 0; i < cbs.length; i++) {
          cb = cbs[i]; cb();
        }
      }
    });
    return {
      then: function(cb) {
        cb && (loaded ? cb() : (cbs.push(cb)));
      }
    };
  })();
})();(function() {
  window.throttle = function(func, wait) {
    var args, result, thisArg, timeoutId, lastCalled = 0;

    function trailingCall() {
      lastCalled = new Date;
      timeoutId = null;
      result = func.apply(thisArg, args);
    }
    return function() {
      var now = new Date,
        remaining = wait - (now - lastCalled);

      args = arguments;
      thisArg = this;

      if (remaining <= 0) {
        clearTimeout(timeoutId);
        timeoutId = null;
        lastCalled = now;
        result = func.apply(thisArg, args);
      } else if (!timeoutId) {
        timeoutId = setTimeout(trailingCall, remaining);
      }
      return result;
    };
  };
})();(function() {
  var Set = (function() {
    var add = function(item) {
      var i, data = this._data;
      for (i = 0; i < data.length; i++) {
        if (data[i] === item) {
          return;
        }
      }
      this.size ++;
      data.push(item);
      return data;
    };

    var Set = function(data) {
      this.size = 0;
      this._data = [];
      var i;
      if (data.length > 0) {
        for (i = 0; i < data.length; i++) {
          add.call(this, data[i]);
        }
      }
    };
    Set.prototype.add = add;
    Set.prototype.get = function(index) { return this._data[index]; };
    Set.prototype.has = function(item) {
      var i, data = this._data;
      for (i = 0; i < data.length; i++) {
        if (this.get(i) === item) {
          return true;
        }
      }
      return false;
    };
    Set.prototype.is = function(map) {
      if (map._data.length !== this._data.length) { return false; }
      var i, j, flag, tData = this._data, mData = map._data;
      for (i = 0; i < tData.length; i++) {
        for (flag = false, j = 0; j < mData.length; j++) {
          if (tData[i] === mData[j]) {
            flag = true;
            break;
          }
        }
        if (!flag) { return false; }
      }
      return true;
    };
    Set.prototype.values = function() {
      return this._data;
    };
    return Set;
  })();

  window.Lazyload = (function(doc) {
    var queue = {js: [], css: []}, sources = {js: {}, css: {}}, context = this;
    var createNode = function(name, attrs) {
      var node = doc.createElement(name), attr;
      for (attr in attrs) {
        if (attrs.hasOwnProperty(attr)) {
          node.setAttribute(attr, attrs[attr]);
        }
      }
      return node;
    };
    var end = function(type, url) {
      var s, q, qi, cbs, i, j, cur, val, flag;
      if (type === 'js' || type ==='css') {
        s = sources[type], q = queue[type];
        s[url] = true;
        for (i = 0; i < q.length; i++) {
          cur = q[i];
          if (cur.urls.has(url)) {
            qi = cur, val = qi.urls.values();
            qi && (cbs = qi.callbacks);
            for (flag = true, j = 0; j < val.length; j++) {
              cur = val[j];
              if (!s[cur]) {
                flag = false;
              }
            }
            if (flag && cbs && cbs.length > 0) {
              for (j = 0; j < cbs.length; j++) {
                cbs[j].call(context);
              }
              qi.load = true;
            }
          }
        }
      }
    };
    var load = function(type, urls, callback) {
      var s, q, qi, node, i, cur,
        _urls = typeof urls === 'string' ? new Set([urls]) : new Set(urls), val, url;
      if (type === 'js' || type ==='css') {
        s = sources[type], q = queue[type];
        for (i = 0; i < q.length; i++) {
          cur = q[i];
          if (_urls.is(cur.urls)) {
            qi = cur;
            break;
          }
        }
        val = _urls.values();
        if (qi) {
          callback && (qi.load || qi.callbacks.push(callback));
          callback && (qi.load && callback());
        } else {
          q.push({
            urls: _urls,
            callbacks: callback ? [callback] : [],
            load: false
          });
          for (i = 0; i < val.length; i++) {
            node = null, url = val[i];
            if (s[url] === undefined) {
              (type === 'js' ) && (node = createNode('script', { src: url }));
              (type === 'css') && (node = createNode('link', { rel: 'stylesheet', href: url }));
              if (node) {
                node.onload = (function(type, url) {
                  return function() {
                    end(type, url);
                  };
                })(type, url);
                (doc.head || doc.body).appendChild(node);
                s[url] = false;
              }
            }
          }
        }
      }
    };
    return {
      js: function(url, callback) {
        load('js', url, callback);
      },
      css: function(url, callback) {
        load('css', url, callback);
      }
    };
  })(this.document);
})();</script><script>
  (function() {
    var TEXT_VARIABLES = {
      sources: {
        font_awesome: 'https://use.fontawesome.com/releases/v5.0.13/css/all.css',
        jquery: 'https://cdn.bootcss.com/jquery/3.1.1/jquery.min.js',
        leancloud_js_sdk: '//cdn1.lncld.net/static/js/3.4.1/av-min.js',
        chart: 'https://cdn.bootcss.com/Chart.js/2.7.1/Chart.bundle.min.js',
        gitalk: {
          js: 'https://cdn.bootcss.com/gitalk/1.2.2/gitalk.min.js',
          css: 'https://cdn.bootcss.com/gitalk/1.2.2/gitalk.min.css'
        },
        mathjax: 'https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML',
        mermaid: 'https://cdn.bootcss.com/mermaid/7.1.2/mermaid.min.js'
      },
      site: {
        toc: {
          selectors: 'h1,h2,h3'
        }
      },
      paths: {
        search_js: '/assets/search.js'
      }
    };
    window.TEXT_VARIABLES = TEXT_VARIABLES;
  })();
</script></head>
  <body>
    <div class="root" data-is-touch="false">
      <div class="layout--page js-page-root"><div class="page__main js-page-main">

    <div class="page__main-inner">
      <div></div><div class="page__header"><header class="header"><div class="main">
      <div class="header__title">
        <div class="header__brand"><svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 width="24px" height="24px" viewBox="0 0 24 24">
<style type="text/css">
	.st0{fill:#515151;}
</style>
<path class="st0" d="M1.7,22.3c5.7-5.7,11.3-5.7,17,0c3.3-3.3,3.5-5.3,0.8-6c2.7,0.7,3.5-1.1,2.3-5.6s-3.3-5.2-6.3-2.1
	c3-3,2.3-5.2-2.1-6.3S7,1.8,7.7,4.6C7,1.8,5,2.1,1.7,5.3C7.3,11,7.3,16.7,1.7,22.3"/>
</svg><a title="基本都是“大老李聊数学”音频节目讲稿 继续以半专业的好奇心解读专业的数学知识，给您轻松愉快的收听体验，带来更多好玩有意思的数学内容。 用收听的方式理解数学，跟您聊聊公理，悖论，数论，函数等各种数学相关话题。还会不定期汇报数学界最新成果和新闻。
" href="/">大老李聊数学</a></div>
        <button class="button button--secondary button--circle search-button js-search-toggle"><i class="fas fa-search"></i></button>
      </div><nav class="navigation">
        <ul><li class="navigation__link"><a href="/archive.html">归档</a></li><li class="navigation__link"><a href="/about.html">关于</a></li><li><button class="button button--secondary button--circle search-button js-search-toggle"><i class="fas fa-search"></i></button></li>
        </ul>
      </nav></div>
  </header>
</div><div class="page__content"><div class ="main"><div class="grid grid--reverse">

             <div class="col-aside js-col-aside"></div>

            <div class="col-main cell--auto"><article itemscope itemtype="http://schema.org/WebPage"><div class="article__header"><header style="display:none;"><h1>主页</h1></header></div><meta itemprop="headline" content="主页"><meta itemprop="author" content="大老李"/><div class="js-article-content"><div class="layout--home"><div class="items items--divided"><article class="item" itemscope itemtype="http://schema.org/BlogPosting"><div class="item__content">
          <header><h2 itemprop="headline" class="item__header"><a href="/2018/08/01/e6-9c-89-e6-84-8f-e6-80-9d-e7-9a-84163-e9-bb-91-e6-a0-bc-e7-ba-b3-e6-95-b0-e9-9f-b3-e9-a2-91-e8-ae-b2-e7-a8-bf.html">有意思的163--黑格纳数 (音频讲稿)</a></h2></header>
          <div class="item__description"><div class="article__content" itemprop="description articleBody"><p>大家好，我是大老李。看到这期的节目标题中的163，你大概第一反应跟我一样，首先想到的是网易。但我声明这期节目没有拿网易一点赞助费，但是163这个数字确实是在数学里有点特别性质的。</p>
<p>要说163的这个特别性质，我们要从质因数分解说起。我们小学时候就知道质因数分解这件事，而且有一个定理叫：唯一因子分解定理。意思就是任何一个整数的质因数分解方式是唯一的，不可能有两种方法。这个定理是如此重要，以至于它有另一个名称叫“算术基本定理”(Fundamental Theorem of Arithmetics )。</p>
<p>但你有没有想过，在引入虚数之后，这个质因数分解有了些新的变化。比如我们算一下$latex (1+i)(1-i)=1-(-1)=2$，这样好像2就有了一种因数分解方法了。当然如果你看到这个结果就当一个奇淫巧技，一带而过了，那什么也不会发生。但大数学家高斯不这样么想，他在1801（高斯时年才26岁）年出版一本数论教材叫《算术研究》（<span class="st">Disquisitiones Arithmeticae</span>）中提出了两个与这个因数分解问题相关的猜想，后世称为“类数问题” (Class Number Problem)。</p>
<p>我们首先要考虑的一个问题是，在引入虚数也就是复数范围内，怎样的数算“质数”？就像前面我说2可以分解成$latex (1+i)(1-i)$如果算一种分解的话，那我凭什么说1+i和1-i算素数？为什么不把2分解成$latex 4\times \frac{1}{2}$，这算不算一种分解呢？所以我们要先定义好新的质数。</p>
<p>数学家发现，如果把有理数集合扩大一些，考察这种类型的数：$latex a+b\sqrt {c}$，考察在这种形式的数构成的集合中的因式分解似乎是一个很有意思的一件事。说明一下，这里a，b是有理数，c则是一个整数。而我们让a,b是变量，c是常量，而且可以是正整数也可以是负整数。你马上能发现c等于0或1或任何完全平方数的话，那就等于这个集合就是有理数集，如果是负完全平方数，则就是整个复数集，这样集合就退化了。所以后面我未加说明时，这个c就默认排除完全平方数。</p>
<p>而考察$latex a+b\sqrt {c}$这种类型的数有啥好处呢？关键在于只要c是固定下来了，那么如果两个数都是$latex a+b\sqrt {c}$的形式，那它们加减乘除之后，总还是能写成$latex a+b\sqrt {c}$的形式。比如前面的例子就是$latex a+b\sqrt {-1}$的形式。你也可以在纸上试试看$latex a+b\sqrt {2}$之类的。你试着找取两组不同的有理数a和b，你会发现把它们无论加减乘除之后，最后的形式总能化简为$latex a+b\sqrt {2}$。这在数学上叫运算封闭性，也就是整个集合里面的元素用加减乘除，你是跳不出整个集合的。其实后来数学家把以上这种$latex a+b\sqrt {c}$数构成的集合叫有理数的二次扩域，而封闭性则是“域”这个代数结构的最基础条件。当然高斯在研究这个问题的时候，“域”这个概念还远没有诞生，你也不用担心，这期节目不需要你任何有关“域”的知识。</p>
<p>以上我们有了一个数集$latex a+b\sqrt {c}$，那我们就要考察下如何在这个数域里对整数做质因数分解。</p>
<p>(注：音频中并未解释在数域$latex a+b\sqrt {c}$，什么样的数算整数。其实此情形下整数的定义为，所有如下形式的数：</p>
<p>$latex a+b\sqrt {c}$，其中a, b是整数（原先是有理数范围）。但某些c值中，整数也可以是此种形式：</p>
<p>$latex a+b(\frac{1+\sqrt {c}}{2})$  。原因较为复杂，详情请自行搜索“代数整数”。)</p>
<p>整数有了，我们很自然就能产生新的质数定义：就是一个整数，如果能写成两个$latex a+b\sqrt {c}$形式的数相乘（其中a,b为整数），则它就是合数，反之则为素数，这听上去是不是很自然？因为这保证了了所谓“兼容性”，比如当c=1的时候，集合退化成有理数，原先的质数也恰好就是这个新定义下的质数。</p>
<p>而高斯当年就是考察了$latex a+b\sqrt {c}$这种类型的数域中，唯一因子分解定理是否成立的情况。他发现不同的c会导致非常不同的结果，有的c可以让唯一因子分解定理继续有效，有的c会使这个定理失效，而且失效的程度会很不一样。有的c可以让一个整数有两种分解方法，有的有三种，四种，甚至很多很多。</p>
<p>高斯在进一步提出了类数(class number)概念，就是以上数域中，一个“整数”可以有的最多的因子分解数量。类数为1，就表示这个数域仍然保持唯一因子分解定理，类数2就是表示一个数最多有2种分解等等。所谓类数问题，就是考察对不同的c，它的类数是多少？于是他提出了两个猜想：</p>
<p>一个是当c大于0时，存在无穷多个c，使得以上类型数域的类数保持1。这个猜想现在被称为“实数二次域上的类数1问题” (class-number one problem for real quadratic fields) ，因为c大于0时，这个数域里都是实数。这个猜想非常难，到现在也没有证明，但今天这是题外话，我不多说了。</p>
<p>第二个猜想是当c小于0的情况，高斯猜想，随着c趋向$latex -\infty $，类数会趋向$latex \infty $。也就是c是绝对值越大的负数，数域中的因子分解方法也会越来越多。这个问题被称为“虚数二次域上的类数n问题”( class-number n problem for imaginary quadratic fields），因为c是负数的话，那数域里就都是虚数了。这个问题也很难，但让我们具体看下n取1的情况，也即是c取哪些负整数，可以是的数域的类数为1，也就是唯一因子分解定理仍然有效。</p>
<p>前面我们做了一个实验$latex (1+i)(1-i)=2$，这等于是取c为-1的情况，我们对2进行了分解，但这并没有使唯一因子分解定理失效，因为2并没有另外的分解方法了，我们只是使2变成了合数。你再多做几次实验，你会感觉c取-1，唯一因子分解定理似乎总是成立的。</p>
<p>另外你的直觉会告诉你，只有c为素数时唯一因子分解定理才可能保持。这个直觉是很对。但c为素数并不是保持唯一因子分解定理的充分条件。比如c取-5，你会发现$latex (1-\sqrt{-5})(1+\sqrt{-5})=1-(-5)=6=2\times 3$。这样6就有两种分解方式了，唯一因子分解定理失效了！</p>
<p>这样一下子就有一个有意思的问题，c取哪些数，可以唯一因子分解定理继续有效呢？这个问题其实进展相当缓慢。第一个突破是1918年，德国数学家艾里希赫克证明了，如果黎曼假设成立，则高斯的第二个猜想成立，也就是c趋向$latex -\infty $，类数趋向$latex \infty $。到了1934年，英国数学家莫代尔和德国数学家汉斯*海尔布隆(Hans Heilbronn)证明了如果黎曼假设不成立，则高斯的第二个猜想成立！</p>
<p>这下你发现了一神奇的情况，不管黎曼假设成不成立，高斯的猜想都成立，所以等于高斯的第二个猜想就被证明了，现在它被称为艾里希赫克-莫代尔-海尔布隆定理。这大概是数学中绝无仅有的一个重要命题证明方式，就是证明了：如果A成立，则B成立；如果A不成立，则B也成立；所以B总是成立，但我们还是不知道A成不成立。</p>
<p>但是以上还不是有关类数为1的问题，但既然c小于0时，类数是趋向无穷大，所以我们知道只能有有限多个整数c，使得类数为1。海尔布隆和另一位数学家Linfoot在1934年证明了最多只能有10个整数c，使得类数为1，而且他们已经确定的发现了9个，他们是：−1, −2, −3, −7, −11, −19, −43, −67, −163。这里163这个数终于出现了！</p>
<p>现在的问题有没有这第十个数，使得类数还是1呢？这里面有一个戏剧化的故事。在1952年，一个德国的60岁的电气工程师，库特·黑格纳发表了一篇论文，宣称证明了没有第10个整数c，也就是以上9个整数就是全部使得类数为1的负整数，这就等于是解决了虚数二次域上的类数1问题。但是由于他本职是电气工程师，所以他的论文不太被重视。而一些数学家看了他的论文后，又发现有一些明显的漏洞，所以数学家认为他的证明不成立。</p>
<p>又过了14年，到1967年，英国的艾伦贝克(Allen Baker）和美国的哈罗德·史塔克（Harold Stark）完整的给出了数学家接受的一个类数1问题就是9个整数的证明，他们此后还因此获得了菲尔兹奖。但史塔克之后在审阅黑格纳的证明时，惊奇的发现黑格纳的证明其实是不错的！虽然里面有些漏洞，但都是可以填补的，而且他的证明思路跟他自己的证明很像。但1967年时，黑格纳已经去世两年，人们为了纪念他，把类数1问题的证明称为史塔克-黑格纳定理，并且把那9个使得唯一因子分解定理在虚数域上继续有效的9个数称为黑格纳数，所以163就是最大的黑格纳数！史塔克本人也说这是一件让人很遗憾的是，就是一个人荣誉死后才能得到，但好在我们还是最终给了黑格纳一些补偿。</p>
<p>这个163这个数字的特殊含义大家应该是清楚了，就是$latex a+b\sqrt {-163}$这样数域中，唯一因子分解定理仍然有效，而且没有更大的数字能保持这个性质。而黑格纳数还有一些好玩的性质，比如$latex n^{2}+n+41$，这个表达式能够生成非常多的素数，而它的判别式恰为-163。</p>
<p>而最好玩的是这样一个数：$latex e^{\pi \sqrt{163}}$，这个数虽然底数和指数都是无理数，但是计算结果是如此接近整数：</p>
<p><img class="alignnone size-full wp-image-1027" src="https://dalaoliblog.files.wordpress.com/2018/08/screen-shot-2018-07-29-at-10-56-56-am.png" alt="Screen Shot 2018-07-29 at 10.56.56 AM" width="646" height="98" /></p>
<p>即小数点后有12个9。它是如此接近整数，以至于马丁加德纳曾经在他1975年的一篇专栏文章中个，开玩笑得说：数学家已经证明了$latex e^{\pi \sqrt{163}}$是一个整数，而且拉曼努金曾经对此做过猜想。</p>
<p>后来马丁加德纳承认这只是玩笑，但要精确计算这个数的小数点后的位数，已经远远超出了当年的计算机的计算能力。即使现在，你随便掏个科学计算器出来，输入$latex e^{\pi \sqrt{163}}$，它也只能回答你，约等于$latex 2.62537..\times 10^{17}$之类。你想这个数整数部分有18位，小数点后有12个9，你要计算出它小数点后第13位，你需要多大精度的$latex e$和$latex \pi$还有$latex \sqrt{163}$的值才能算。当然，你可以用级数展开式来算，但仍然十分复杂。其实我们现在能知道它小数点后那么多位，不是死算出来的，而是用这个数其他数学性质方法算的。而以上这个数如此接近整数也不是巧合，其实是与之前的类数1问题是有十分深刻的联系的。而这种数被称为“近整数”，也是一个很有意思的话题，有机会再聊。</p>
<p>以上这个近整数现在被称为拉马努金常数，但其实这个数最早是1859年，赫密特发现的。但人们觉得这个数字的风格太像拉马努金的风格了，所以就叫它“拉马努金常数”。</p>
<p>好了，以上终于讲完了163的特别之处。其实类数问题是数论中最为艰深的领域之一，以上我们只说了虚数二次域的类数1问题，还有类数2问题，类数3问题的等等。还有实数二次域的类数问题没有解决。还有三次域，四次域，以及各种数域里，其实都有类数问题。你要钻进去的话，够你研究一辈子。反正我是看到从一个数域和因子分解问题能扩展出那么多问题，不得不感叹数学的博大精深。</p>
<p>另外需要指出这个问题与费马大定理十分相关，历史上很多人声称他们证明了费马大定理，但他们都不自觉的在超过有理数范围内默认唯一因子分解定理成立，从而犯下错误了。可以说，唯一因子分解定理是证明费马大定理时第一个大的陷阱。</p>
<p>好了，今天聊得差不多了。我相信你下次看到163这个数，你不光能想到网易，还能想到它是最大的黑格纳数和拉马努金常数的一部分。下期再见！</p>
<p>思考题：</p>
<p>因为-2是一个黑格纳数，所以$latex a+b\sqrt{-2}$域中，唯一因子分解定理应该是成立的。但大老李计算了一下：</p>
<p>$latex (1+2\sqrt{-2})(1-2\sqrt{-2})=1-(-8)=9=3\times 3$，这样9看上去就有两种分解方法。请问问题出在哪里？</p>
</div><p><a href="/2018/08/01/e6-9c-89-e6-84-8f-e6-80-9d-e7-9a-84163-e9-bb-91-e6-a0-bc-e7-ba-b3-e6-95-b0-e9-9f-b3-e9-a2-91-e8-ae-b2-e7-a8-bf.html">阅读更多</a></p></div><div class="article__info clearfix"><ul class="right-col menu"><li><i class="fas fa-user"></i> <span>大老李</span></li><li><i class="far fa-calendar-alt"></i> <span>2018年 08月01日</span>
            </li></ul></div><meta itemprop="author" content="大老李"/><meta itemprop="datePublished" content="2018-08-01T12:30:44+00:00"></div>
      </article><article class="item" itemscope itemtype="http://schema.org/BlogPosting"><div class="item__content">
          <header><h2 itemprop="headline" class="item__header"><a href="/2018/07/29/e6-af-8f-e5-91-a8-e4-b8-80-e9-a2-98-ef-bc-9a-e5-88-86-e5-89-b2-e6-ad-a3-e6-96-b9-e5-bd-a2-ef-bc-88-e9-99-84-e4-b8-8a-e6-9c-9f-e7-ad-94-e6-a1-88-ef-bc-89.html">每周一题：分割正方形（附上期答案）</a></h2></header>
          <div class="item__description"><div class="article__content" itemprop="description articleBody"><h1>本期题目：分割正方形（附上周答案）</h1>
<p>（题目来源：Varsity Math）</p>
<p><img class=" size-full wp-image-1018 aligncenter" src="https://dalaoliblog.files.wordpress.com/2018/07/square.jpg" alt="square.jpg" width="221" height="228" /></p>
<p>请你将一个正方形分割成4个<strong>不同大小</strong>的部分，且每个部分都是等腰三角形。请问如何分割？</p>
<p>请直接留言，留下其中最小的一个等腰三角形的顶角度数即可。</p>
<hr />
<h1>上期答案：</h1>
<p>上周题目是：</p>
<blockquote><p><img class="alignnone size-full wp-image-1011" src="https://dalaoliblog.files.wordpress.com/2018/07/rectangles.jpeg" alt="rectangles.jpeg" width="772" height="426" /></p>
<p>你得到许多由两个任意大小矩形“粘贴”在一起，如L形的木板（参见上图）。也可以认为是一个大的矩形被切去了一个角。你现在的任务是对这些木板进行切割，要求切下的两块面积相等。切割要求是：</p>
<ul>
<li>画出一条直线，恰好平分木板面积，形状不论。</li>
<li>只能用一把没有刻度的直线作为工具（即只能使用尺规作图法操作，但不能使用圆规）。</li>
</ul>
<p>请你找出最简单的作图法。这个最简单的作图法应该是足够简单可以留言回答的：）</p>
<p>请直接留言作答。</p></blockquote>
<p>答案是：</p>
<p>本题以下这点就很简单了：一条直线能平分矩形的话，当且仅当这条直线通过矩形的中心点，即两条对角线的交点。</p>
<p>观察到原先图形是两个矩形的组合，所以我们可以找到两个矩形的中心，再连接起来就完成了：</p>
<p><img class="alignnone size-full wp-image-1014" src="https://dalaoliblog.files.wordpress.com/2018/07/l-bisect-alt0-1200x434.png" alt="L-bisect-alt0-1200x434.png" width="1200" height="434" /></p>
<p>或者把原先图形看作大矩形“减去”一个小矩形，因此可以把大矩形补全，在找到大小矩形的中心，连线也可以，这个方法比前面那个稍简单点：</p>
<p><img class="alignnone size-full wp-image-1015" src="https://dalaoliblog.files.wordpress.com/2018/07/l-bisect-768x582.png" alt="L-bisect-768x582.png" width="768" height="582" /></p>
<p>有意思的是以上这种方法对两个矩形的位置并无要求，只要两个矩形不是部分重叠即可：</p>
<p>&nbsp;</p>
<p><img class="alignnone size-full wp-image-1016" src="https://dalaoliblog.files.wordpress.com/2018/07/l-bisect-alt1-1200x881.png" alt="L-bisect-alt1-1200x881.png" width="1200" height="881" /></p>
<p>还能推广到其他有对称性的图形上：</p>
<p><img class="alignnone size-full wp-image-1017" src="https://dalaoliblog.files.wordpress.com/2018/07/l-bisect-alt2.png" alt="L-bisect-alt2.png" width="651" height="583" /></p>
<p>&nbsp;</p>
<p>恭喜（如有遗漏请见谅）：<strong>高兴就好，谢，唐，<span class="buddy-card_name">Chauncey Rao</span>，φ，小宇鱼 (●—●)🐟，黄亮，Stones，韩w，Eric，heavy sun，wwz，One Dolphin</strong>答对了！</p>
<hr />
<p><strong>大老李聊数学”第二季已开播！</strong>识别如下二维码即可：</p>
<p><img class="alignnone size-full wp-image-898" src="https://dalaoliblog.files.wordpress.com/2018/05/ximalaya_season1.png" alt="ximalaya_season1.png" width="426" height="418" /></p>
<p>下周再见！</p>
<hr />
<p>关注“大老李聊数学”公众号，微信搜索： dalaoli_shuxue</p>
<p>&nbsp;</p>
</div><p><a href="/2018/07/29/e6-af-8f-e5-91-a8-e4-b8-80-e9-a2-98-ef-bc-9a-e5-88-86-e5-89-b2-e6-ad-a3-e6-96-b9-e5-bd-a2-ef-bc-88-e9-99-84-e4-b8-8a-e6-9c-9f-e7-ad-94-e6-a1-88-ef-bc-89.html">阅读更多</a></p></div><div class="article__info clearfix"><ul class="right-col menu"><li><i class="fas fa-user"></i> <span>大老李</span></li><li><i class="far fa-calendar-alt"></i> <span>2018年 07月29日</span>
            </li></ul></div><meta itemprop="author" content="大老李"/><meta itemprop="datePublished" content="2018-07-29T12:23:08+00:00"></div>
      </article><article class="item" itemscope itemtype="http://schema.org/BlogPosting"><div class="item__content">
          <header><h2 itemprop="headline" class="item__header"><a href="/2018/07/22/e6-af-8f-e5-91-a8-e4-b8-80-e9-a2-98-ef-bc-9a-e5-b9-b3-e5-88-86-e7-bc-ba-e8-a7-92-e7-9f-a9-e5-bd-a2-ef-bc-88-e9-99-84-e4-b8-8a-e6-9c-9f-e7-ad-94-e6-a1-88-ef-bc-89.html">每周一题：平分“缺角”矩形（附上期答案）</a></h2></header>
          <div class="item__description"><div class="article__content" itemprop="description articleBody"><h1>本期题目：平分“缺角”矩形（附上周答案）</h1>
<p>（题目来源：fivethirtyeight.com）</p>
<p><img class="alignnone size-full wp-image-1011" src="https://dalaoliblog.files.wordpress.com/2018/07/rectangles.jpeg" alt="rectangles.jpeg" width="772" height="426" /></p>
<p>你得到许多由两个任意大小矩形“粘贴”在一起，如L形的木板（参见上图）。也可以认为是一个大的矩形被切去了一个角。你现在的任务是对这些木板进行切割，要求切下的两块面积相等。切割要求是：</p>
<ul>
<li>画出一条直线，恰好平分木板面积，形状不论。</li>
<li>只能用一把没有刻度的直线作为工具（即只能使用尺规作图法操作，但不能使用圆规）。</li>
</ul>
<p>请你找出最简单的作图法。这个最简单的作图法应该是足够简单可以留言回答的：）</p>
<p>请直接留言作答。</p>
<hr />
<h1>上期答案：</h1>
<p>上周题目是：</p>
<blockquote><p><img class=" size-full wp-image-992 aligncenter" src="https://dalaoliblog.files.wordpress.com/2018/07/b3-ay538_mathdi_g_20180627164511.jpg" alt="B3-AY538_MATHdi_G_20180627164511.jpg" width="553" height="369" /></p>
<p>你去一个有大房子的朋友家参加泳池派对。这个朋友家有一个巨大的圆形泳池，泳池与他家的院子相切。且泳池的一角有一个9米*2米大小的矩形平台，与泳池相切。（具体请看示意图）。</p>
<p>问你这个朋友家的院子有多大？</p></blockquote>
<p>答案是：你这个朋友家的院子有34*34=1156平方米那么大。</p>
<p>设院子的左下角为一个坐标系原点，平台右上角那点的坐标是(9, 2)。设游泳池的圆心坐标是(r, r)。则可得方程：</p>
<p>$latex (r-9)^{2}-(r-2)^{2}=r^{2}$</p>
<p>可解得r=17。则院子边长为17*2=34米。</p>
<p>恭喜（如有遗漏请见谅）：<strong>Eric, 天天快乐，云水禅心，糖，Heavy Sun，</strong><strong>Chauncey Rao，红岩，安涛，高兴就好，韩w，One Dophin，蝈蝈，Stones，委员长，Lian，黄亮</strong>答对了！</p>
<hr />
<p><strong>大老李聊数学”第二季已开播！</strong>识别如下二维码即可：</p>
<p><img class="alignnone size-full wp-image-898" src="https://dalaoliblog.files.wordpress.com/2018/05/ximalaya_season1.png" alt="ximalaya_season1.png" width="426" height="418" /></p>
<p>下周再见！</p>
<hr />
<p>关注“大老李聊数学”公众号，微信搜索： dalaoli_shuxue</p>
<p>&nbsp;</p>
</div><p><a href="/2018/07/22/e6-af-8f-e5-91-a8-e4-b8-80-e9-a2-98-ef-bc-9a-e5-b9-b3-e5-88-86-e7-bc-ba-e8-a7-92-e7-9f-a9-e5-bd-a2-ef-bc-88-e9-99-84-e4-b8-8a-e6-9c-9f-e7-ad-94-e6-a1-88-ef-bc-89.html">阅读更多</a></p></div><div class="article__info clearfix"><ul class="right-col menu"><li><i class="fas fa-user"></i> <span>大老李</span></li><li><i class="far fa-calendar-alt"></i> <span>2018年 07月22日</span>
            </li></ul></div><meta itemprop="author" content="大老李"/><meta itemprop="datePublished" content="2018-07-22T07:22:04+00:00"></div>
      </article><article class="item" itemscope itemtype="http://schema.org/BlogPosting"><div class="item__content">
          <header><h2 itemprop="headline" class="item__header"><a href="/2018/07/19/e4-b8-89-e7-bb-b4-e4-b8-96-e7-95-8c-e4-b8-ad-e7-9a-84-e5-92-8c-e8-b0-90-e6-af-94-e4-be-8b-e5-a1-91-e6-96-99-e5-b8-b8-e6-95-b0.html">三维世界中的“和谐”比例--塑料常数</a></h2></header>
          <div class="item__description"><div class="article__content" itemprop="description articleBody"><p>大家好，我是大老李。今天聊一个可能对多数人还很陌生的常数，叫“塑料常数”，英文就叫Plastic Constant。</p>
<p>这个数字的定义很简单，它就是方程$latex x^{3}=x+1$的唯一实数根，约等于1.3247或4/3。我们知道三次方程是有根式解的，所以这个塑胶常数有一个根式表达形式:</p>
<p>$latex { {\sqrt[{3}]{ {\frac {1}{2}}+{\frac {1}{6}}{\sqrt {\frac {23}{3}}}}}+{\sqrt[{3}]{ {\frac {1}{2}}-{\frac {1}{6}}{\sqrt {\frac {23}{3}}}}}}$</p>
<p>$latex { {\sqrt[{3}]{ {\frac {1}{2}}+{\frac {1}{6}}{\sqrt {\frac {23}{3}}}}}+{\sqrt[{3}]{ {\frac {1}{2}}-{\frac {1}{6}}{\sqrt {\frac {23}{3}}}}}}$</p>
<p>它既然代数方程的根，那它就是一个代数数，而不是超越数。我们知道很多常数比如$latex \pi$，$latex e$都是超越数。超越数给我们的感觉是充满神秘感的，而代数数的神秘感就差很多。那为什么我们还要赋予这个数一个特殊的名字呢？</p>
<p>你可能也注意到，这个数字的定义与黄金分割比例有点像。黄金分割比就是方程$latex x^{2}=x+1$的解。现在这个塑料常数就是把方程左边的平方，改成了立方。那么它们之间有联系吗？被你猜对了，确实有联系，让我们还是从这个常数的来历说起。</p>
<p>话说在1924年，法国工程师Gérard Cordonnier就专门研究过这个数，他当时只有17岁，他把这个数命名为“辐射数”。但四年之后，荷兰建筑师van den Laan发表了有关这个数在自然界中的属性和在建筑美学上应用，并且他把这个数字命名为“塑料常数”，当年他也才24岁。这也是挺有意思的一件事，像$latex x^{3}=x+1$这样的方程，过去对数学家来说，已经研究了很多了，人们也知道这个方程的那个实数解的一些特别性质。但经过这个建筑师研究后，发现了不同的意义，人们才发现原来这个数字是在自然界中是有一些美学含义的，所以人们接受了Laan命名的“塑料常数”这个名字。Laan的结论是塑胶常数不但是“美”，更重要的是所谓“清晰”(Clarity)的。</p>
<p>Laan的发现是从思考两个问题开始，这两个问题都是关于我们如何感受现实中物体的长度，大小，以及如何把他们归类的。</p>
<p>第一个问题是这样：比如我给你看一系列大小不同的正方形，有20个。两面最小的边长是5，最大的是25，是最小的5倍，我在节目介绍里就放了这样一张图，请你看了一下，是不是你第一感会自动的把这些正方形分类，一些是属于“偏小”的，一些是“大”的，尽管这些正方形大小都是渐变的，所以不能严格的归为大或小两类，但是你的大脑还是会这样去做。Laan问的第一个问题就是：当两个物体长度是a和b，且a&gt;b，当a:b的比值大于多少之后，你的大脑会把它们归为两类呢？也就是a比b要长到多少比例，你的大脑会认为区别足够大了，应该分为2类了。这是第一个问题。</p>
<p><img class="alignnone size-full wp-image-995" src="https://dalaoliblog.files.wordpress.com/2018/07/screen-shot-2018-07-18-at-8-52-53-pm.png" alt="Screen Shot 2018-07-18 at 8.52.53 PM.png" width="860" height="816" /></p>
<p style="text-align:center;">（上图：你看到上图，第一感会把上图如何“分类”）</p>
<p>第二个问题是这样，比如卖西瓜。如果西瓜不是按重量卖，而是按数量卖，那么显然老板必须把差不多一样大小的西瓜放在一起标一个价，你不能差太多，否则顾客都会挑大的。现在问题就是，两个西瓜大小之间的差距在什么样的范围内，人们才会认为它们的大小差不多呢？也就是你是瓜店老板的话，你会把差距在这个范围内的瓜放在一起，而你作为顾客的挑选话，你选瓜时也不太会在意它们的大小区别。</p>
<p>这两个问题看上去都很不“科学”，不像数学问题，更像心理学的问题。但这不妨碍去做这个实验。建筑师Laan真请人做了些实验，最后统计结果出来了：对第一个问题，答案约等4/3。第二个问题，约1/7。也即是当两个物体之间的长度比值达到4/3以上了，你的大脑会把它们划分为两类。而两个东西的大小差距在1/7以内，你的大脑会倾向忽略它们之间的大小区别。这两个数字看上去有点矛盾，其实它们是出现在不同的场景。4/3这个数字是出现在对很多物体需要快速按大小分类的时候。第二个数字是出现在你对两个物体的大小需要进行区分的时候，所以并不矛盾。而且接下来你会发现，这两个数字其实是有统一的来源的。</p>
<p>Laan建筑师指出，这两个数字其实就是来源于黄金分割比的一个扩展。我们知道黄金分割比是这样定义，一根线段切成两段，我们要使的整个一段长度与较长的一段的比，等于较长的一段比较短的一段，而这个比值，约1.618就是黄金分割比。现在稍微扩展一下，请你考虑一下把一个线段取两个点分为长度不同三段。这样两个分点加线段两端点，我如果任取两点的话，可以得到6种不同的长度组合，如果我把这6段不同的长度组合按最长到最小排列起来，并且要求相邻的两段长度之间的比值都要相等，问这个分点取在哪里，比值又是多少？</p>
<p style="text-align:center;"><img class="alignnone size-full wp-image-996" src="https://dalaoliblog.files.wordpress.com/2018/07/screen-shot-2018-07-18-at-8-56-23-pm.png" alt="Screen Shot 2018-07-18 at 8.56.23 PM.png" width="862" height="734" /><br />
(上图左：黄金分割的来历。上图右：塑料常数的来历，相邻两段比例全部相等)</p>
<p>如果你有时间，可以暂停一下，马上做做看这道智力题。这个问题答案就是塑料常数，约4/3。而那个1/7怎么来的呢，你把塑料常数的七次方非常接近7，它的倒数就是1/7。也就是一个线段长度按塑料常数的比例不断拉长7次后，它的长度接近原来的7倍，原来的长度是它的1/7。</p>
<p>你也马上能发现，既然分成3点能得到一个常数，分成4个点，5个点，6个点，应该都可以啊。是的，Laan工程师发现，如果一个线段分成n个点，要使分出的线段之间的比例如之前例子中的“和谐”状态，那这个比例会符合方程$latex x^{n}=x+1$。如果n=2，这就是黄金分割，n=3，就是塑料常数。n&gt;3之后，也能求出一个在1与2之间的实数解，而且n越大，比值越小。Laan把这个数列第n个数，称为n维空间的和谐数（harmonious number，或Clarity number“清晰数”）。而因为人类生活在三维空间，所以人类无法感受n大于3之后的和谐数，但是我们能感受到n=2时，黄金分割比带来的美感和n=3时，这个塑料常数带来的和谐感和所谓“清晰感”（Clarity）。他的所谓“清晰感”是有点抽象的概念，之后你可以自己体会一下。</p>
<p>据说有人做过实验，给人们从不同长宽比的矩形里找最具美感的，结果发现人们都选择长宽比接近黄金分割比的。而Laan认为，如果给人们从很多不同长宽高的立方体里面选择最美的，他们会选出符合塑料常数比值的立方体，而且他也发现古希腊人建筑中，不自觉的运用了这个比值。我在节目介绍里，也会放几张这样的立方体，大家感受一下，是不是比较有美感。</p>
<p><img class="alignnone size-full wp-image-997" src="https://dalaoliblog.files.wordpress.com/2018/07/screen-shot-2018-07-18-at-9-02-54-pm.png" alt="Screen Shot 2018-07-18 at 9.02.54 PM.png" width="836" height="528" /></p>
<p>(上图左：按黄金分割比例嵌套的正方形。上图右：长宽高之比符合塑料常数的立方体，你看的出美感吗？)</p>
<p>那为什么要叫它塑料常数呢？其实按理说既然有黄金分割比，按接下来就应该是白银分割比，是吧？但一个是因为有另一个数字已经被称为白银分割比了，Laan建筑师也不想搞“圣斗士”那套东西，他就直接叫它“塑料常数”，因为塑料就是三维材料，而这个常数在三维世界发挥作用的一个常数。不过后来，确实也有人把这个常数称为“银数”。</p>
<p><img class="alignnone size-full wp-image-1006" src="https://dalaoliblog.files.wordpress.com/2018/07/screen-shot-2018-07-18-at-9-32-12-pm.png" alt="Screen Shot 2018-07-18 at 9.32.12 PM.png" width="930" height="822" /></p>
<p style="text-align:center;">(上图：Lann建筑师设计的一座修道院，你能看出其中“塑料常数”的运用吗？)</p>
<p>好了，以上塑料常数的来历说完，说几个它的重要性质。一个是塑料常数是所谓佩兰数列和巴都万数列的两项之间的比值极限。佩兰数列和巴都万数列的定义跟斐波那契数列很像。斐波那契数列是当前项是前两项之和，而佩兰数列和巴都万数列是跳过上一项，取再前两项之和，也就是$latex a_{n}=a_{n-2}+a_{n-3}$。佩兰数列和巴都万数列的区别仅是起始的三项不同。斐波那契数列相邻两项之间的比值极限是黄金分割，而佩兰数列和巴都万数列相邻两项之间的比就是塑料常数，这里也可以看出塑料常数与黄金分割比的联系。</p>
<p>而另一个性质是塑料常数是所谓皮索特-维贡伊拉卡文数(<b>Pisot–Vijayaraghavan number</b>)，简称PV数中最小的一个。PV数的一个有意思性质就是虽然pv数都是无理数，但是这些数的某些幂次会非常接近整数，比如这个塑料常数的15次方就非常接近70。如果你去看其他PV数的某些幂次，会更加接近整数，相当有意思。</p>
<p>$latex (3+{\sqrt {10}})^{6}=27379+8658{\sqrt {10}}=54757.9999817\dots \approx 54758-{\frac {1}{54758}}$</p>
<p>(上图：PV数$latex 3+{\sqrt {10}}$的6次方与整数是如此接近)</p>
<p>最后值得一提的是有人分析了一下塑料常数与音阶联系，确实发现塑料常数与12平均律的音阶是有紧密联系的。我也随手找了一下所谓内六角扳手尺寸表(L值），发现里面很多不同规格的扳手的内径尺寸差距还真的很接近1/7，不知道这是不是不自觉中“塑料常数”在起作用，因为前面说过人们觉得两样东西的尺寸差距超过1/7了，这就算两样东西了，需要不同规格了。</p>
<p><img class="alignnone size-full wp-image-1002" src="https://dalaoliblog.files.wordpress.com/2018/07/wkgknftmbtusgkcsaa1rkievmsw849.png" alt="wKgKnFtMBTuSGKCSAA1rkIeVMsw849.png" width="750" height="608" /></p>
<p>我还想到的一个著名实验，是让你在心里想一个1到10之间的一个整数，据说2/3以上的人第一感想到7，我觉得是不是也与这个“塑料常数”有关呢？请听众朋友也能想想身边有没有什么事物可能是与塑料常数相关的，也欢迎你告诉我你的发现。我们下期再见！</p>
<p>&nbsp;</p>
</div><p><a href="/2018/07/19/e4-b8-89-e7-bb-b4-e4-b8-96-e7-95-8c-e4-b8-ad-e7-9a-84-e5-92-8c-e8-b0-90-e6-af-94-e4-be-8b-e5-a1-91-e6-96-99-e5-b8-b8-e6-95-b0.html">阅读更多</a></p></div><div class="article__info clearfix"><ul class="right-col menu"><li><i class="fas fa-user"></i> <span>大老李</span></li><li><i class="far fa-calendar-alt"></i> <span>2018年 07月19日</span>
            </li></ul></div><meta itemprop="author" content="大老李"/><meta itemprop="datePublished" content="2018-07-19T11:36:44+00:00"></div>
      </article><article class="item" itemscope itemtype="http://schema.org/BlogPosting"><div class="item__content">
          <header><h2 itemprop="headline" class="item__header"><a href="/2018/07/15/e6-af-8f-e5-91-a8-e4-b8-80-e9-a2-98-ef-bc-9a-e9-99-a2-e5-ad-90-e7-9a-84-e5-a4-a7-e5-b0-8f-ef-bc-88-e9-99-84-e4-b8-8a-e6-9c-9f-e7-ad-94-e6-a1-88-ef-bc-89.html">每周一题：院子的大小（附上期答案）</a></h2></header>
          <div class="item__description"><div class="article__content" itemprop="description articleBody"><h1>本期题目：院子的大小（附上周答案）</h1>
<p>（题目来源：varsity-math）</p>
<p><img class=" size-full wp-image-992 aligncenter" src="https://dalaoliblog.files.wordpress.com/2018/07/b3-ay538_mathdi_g_20180627164511.jpg" alt="B3-AY538_MATHdi_G_20180627164511.jpg" width="553" height="369" /></p>
<p>你去一个有大房子的朋友家参加泳池派对。这个朋友家有一个巨大的圆形泳池，泳池与他家的院子相切。且泳池的一角有一个9米*2米大小的矩形平台，与泳池相切。（具体请看示意图）。</p>
<p>问你这个朋友家的院子有多大？</p>
<p>请直接留言作答。</p>
<hr />
<h1>上期答案：</h1>
<p>上周题目是：</p>
<blockquote><p>世界杯如火如荼进行中，请你考虑一个世界杯中的概率题：在一届世界杯32支球队中，出现（至少一次）两支球队互相遭遇两次的概率是多少？</p>
<p>注：世界杯中两支球队遭遇两次的唯一情况是，一次在小组赛中相遇，一次在决赛或者三四名比赛中相遇。同时我们假设每一支球队的水平或赢球概率是一样的。</p>
<p>本届世界杯中，同一小组出现的英格兰和比利时都还在，他们有可能在3，4名比赛中遭遇。</p></blockquote>
<p>答案是：答案是<strong>7/32，约22%</strong>。</p>
<p>思考并不太复杂，因为每支球队水平一样，所以先可以确定上半区的比赛情况，不妨假设上半区A组的球队进入决赛，半决赛中A组的球队淘汰了E组的球队。这样下半区A组另一支出线球队进入决赛的概率是1/8，E组另一支球队进入三四名决赛概率也是1/8。而这两种情况同时发生的概率是1/4<em>1/4</em>1/2=1/32。</p>
<p>根据“容斥原理”，至少发生一次两支球队相遇的概率为1/8+1/8-1/32=7/32。</p>
<p>恭喜：<strong>Lian，韩w，黄亮和“大老李聊数学”微信群中的一些群友</strong>答对了！</p>
<p>后记：本届比赛中，同一小组出线的英格兰和比利时真的再次在3，4名比赛中相遇了，跟大老李出题时预测的一模一样！可惜没有去买彩票啊。</p>
<hr />
<p><strong>大老李聊数学”第二季已开播！</strong>识别如下二维码即可：</p>
<p><img class="alignnone size-full wp-image-898" src="https://dalaoliblog.files.wordpress.com/2018/05/ximalaya_season1.png" alt="ximalaya_season1.png" width="426" height="418" /></p>
<p>下周再见！</p>
<hr />
<p>关注“大老李聊数学”公众号，微信搜索： dalaoli_shuxue</p>
<p>&nbsp;</p>
</div><p><a href="/2018/07/15/e6-af-8f-e5-91-a8-e4-b8-80-e9-a2-98-ef-bc-9a-e9-99-a2-e5-ad-90-e7-9a-84-e5-a4-a7-e5-b0-8f-ef-bc-88-e9-99-84-e4-b8-8a-e6-9c-9f-e7-ad-94-e6-a1-88-ef-bc-89.html">阅读更多</a></p></div><div class="article__info clearfix"><ul class="right-col menu"><li><i class="fas fa-user"></i> <span>大老李</span></li><li><i class="far fa-calendar-alt"></i> <span>2018年 07月15日</span>
            </li></ul></div><meta itemprop="author" content="大老李"/><meta itemprop="datePublished" content="2018-07-15T02:30:39+00:00"></div>
      </article><article class="item" itemscope itemtype="http://schema.org/BlogPosting"><div class="item__content">
          <header><h2 itemprop="headline" class="item__header"><a href="/2018/07/14/e9-9a-8f-e6-9c-ba-e4-b8-8d-e6-98-af-e8-83-a1-e6-9d-a5-ef-bc-882-ef-bc-89-e9-9a-8f-e6-9c-ba-e6-95-b0-e7-9a-84-e7-94-9f-e6-88-90-ef-bc-88-e8-ae-b2-e7-a8-bf.html">“随机”不是“胡来”（2）--随机数的生成（讲稿）</a></h2></header>
          <div class="item__description"><div class="article__content" itemprop="description articleBody"><p>大家好，我是大老李。这期继续上期话题，聊聊随机数。上期讲了随机数的检验，这次讲讲随机数的生成和算法，这是一个比上一期更大的话题。</p>
<p>你可能听说过计算机里的随机数生成算法叫“伪随机数生成算法”，又叫“决定式随机位生成器”（<b>deterministic random bit generator</b> (<b>DRBG</b>)），意思就是它能随机生成1个二级制位，0或者1，而且是50%概率。为什么这种算法都是二进位的生成器？因为平时我们使用均匀分布随机数的场合是最多的，有了均匀分布的随机数，转换成其他分布也是比较简单的。而计算机内部又都是二进位，我有了产生0和1的二进位生成器，如果一个计算机内部浮点数是小数点后有32位，那我就可以产生32位随机二进位，作为0之后的32位小数位，这样我可以产生0-1之间的均匀分布的浮点数，供用户使用。</p>
<p>那为什么又叫“伪随机数生成算法”？为什么加一个“伪”字？很自然就是因为它达不到上一期讲过的“真随机数“的要求，目前计算机架构下也永远不可能有”真“随机数生成算法。但好在实际运用中我们不需要那么高的要求，在实际使用中，我们只要保证根据相当长历史随机数，你无法用当代主流的计算能力，在相当长的时间内，对我之后随机数的猜测的成功或失败概率，与½之间，无法产生任何“显著”的区别，或者用一个术语，就是差别是“可忽略的”（neglectable），就是你猜我随机数的成功失败概率与瞎猜之间的区别是可忽略的，那我就是很放心的。</p>
<p>具体来看伪随机数算法主要“伪”在它是有周期的，就是这个算法在输出到非常多的随机数之后，你会发现它又开始之前的模式了，开始重复自己了。只是这个周期是非常大的，我们不可能在一个软件的运行寿命内观察到这周期的发生。</p>
<p>但也因为有周期，我们不能让算法总是从固定的位置开始产生随机位，否则每次随机数重新产生都是从一样的数字开始，这是不行的。所以就需要一个所谓的“种子数”, 英文叫seed，去决定从周期中的哪个位置开始产生随机数。这一点对编程的人来说太熟悉不过了，第一次编程的人都会发现如果没有初始化“种子”，系统的随机函数总是返回同样的数。这里有个小尴尬就是为了产生随机数，我们先需要一个随机数作为“种子”。对不严格场合，我们经常会使用当前系统时间的毫秒数作为种子数，但在一些对安全性要求很高的场合，人们还会使用更复杂的方法产生这个seed，之后会聊到。</p>
<p>很惊奇的是，计算机发明开始至今，很长时间里人们所使用的随机数生成算法是很粗糙的。比如计算机刚发明的1940年代，冯诺依曼就想了一个所谓“平方取中”法，来产生随机数。取一个四位数，比如1234作为种子，算一下它的平方是1522756，在左边填充1个0，变01522756，然后他把中间四个数字输出作为随机数，就是5227。然后对5227再求平方取中间四位重复操作下去。这个算法你一听就有问题啊，我看到上一个数字就非常简单知道下一个输出是多少，都不用管你的种子数，怎么能叫随机数呢？但是冯诺依曼觉得这种随机数已经符合他的需求了，速度快，需要的资源也少，而且有可重复性，便于排错。如果使用其他硬件设备产生随机数，比如打孔纸带机作输入，那速度太慢了，消耗的资源也太大。那时，冯诺依曼也指出，如果用过于复杂的数学来产生所谓“随机数”，那可能隐藏的错误比解决的问题还多。</p>
<p><img class=" size-full wp-image-985 aligncenter" src="https://dalaoliblog.files.wordpress.com/2018/07/fennuoyiman.jpg" alt="fennuoyiman.jpg" width="292" height="172" /></p>
<p style="text-align:center;">（上图：冯诺依曼与早期计算机）</p>
<p>但显然冯诺依曼这种算法是不能满足很多场合的随机数需要的，从1960年代，人们开始普遍采用一种叫“线性同余法“，简称LCG算法来产生随机数。这个线性同余算法是非常简单的，就是考虑这么一个函数$latex ax+b \bmod c$，把余数作为随机数，然后下一个随机数就是把上一个余数作为x，迭代计算下一个余数。甚至于b可以取0，就是ax除以c求余数就可以了。各位可以自行做个简单实验，比如a=2, c=9，分别取1，2，3作为种子数，也就是第一个x，你迭代计算下2x除以9的余数，看看是不是像随机数。实际使用时，可以把每个余数转化成二进制数，依次输出。</p>
<p>LCG算法的递推公式：</p>
<p>$latex X_{n+1}=\left(aX_{n}+c\right)~~{\bmod {~}}~m$</p>
<p>我之后也会在公众号里推送这期节目讲稿时，附带一个线性同余随机数的python语言的代码以及一些简单测试，随机数生成函数体简单到只有2行。（这个代码我是取自国外知名数学博客博主John D. Cook，感谢他）。</p>
<p><code>from math import sqrt, log</code><br />
<code># Linear congruence generator (LCG) constants</code><br />
<code>z = 20170705 # seed</code><br />
<code>a = 742938285 # multiplier</code><br />
<code>e = 31 # will need this later</code><br />
<code>m = 2**e -1 # modulus</code><br />
<code># Number of random numbers to generate</code><br />
<code>N = 50</code></p>
<p><code># Format to print bits, padding with 0's on the left if needed</code><br />
<code>formatstr = "0" + str(e) + "b"</code></p>
<p><code>bit_string = ""</code><br />
<code>for _ in range(N):</code><br />
<code>    z = a*z % m # LCG</code><br />
<code>    bit_string += format(z, formatstr)</code><br />
<code>def count_ones(string):</code><br />
<code>    ones = 0</code><br />
<code>    for i in range(len(string)):</code><br />
<code>        if string[i] == '1':</code><br />
<code>        ones += 1</code><br />
<code>    return ones</code></p>
<p><code>def runs(string):</code><br />
<code>max_run = 0</code><br />
<code>    current_run = 0</code><br />
<code>    for i in range(len(string)):</code><br />
<code>       if string[i] == '1':</code><br />
<code>           current_run += 1</code><br />
<code>    else:</code><br />
<code>        current_run = 0</code><br />
<code>    max_run = max(max_run, current_run)</code><br />
<code>    return max_run</code><br />
<code>print (bit_string)</code><br />
<code>ones = count_ones(bit_string)</code><br />
<code>expected = e*N/2</code><br />
<code>sd = sqrt(0.25*N)</code><br />
<code>print( "Number of 1's: {}".format(ones) )</code><br />
<code>print( "Expected: {} to {}".format(expected - 2*sd, expected + 2*sd) )</code></p>
<p>以上这个算法的优点是很明显的，就是简单，高效。而且只要把那个被除的C搞的足够大，我就可以把周期也搞得非常长，而且能通过上期讲过的几乎所有统计学测试。所以该算法一出现就广被使用，以至于至今Java语言标准库里的Random函数，仍然是用的LCG算法，里面的被除数c是$2^{48}$，因为计算机里如果除以2幂次的计算是最快的，只要移位就可以了。a是一个奇怪的数字25214903917，b=11。然后每次不是把余数都输出，而是倒过来输出第47位到第16位，因为更高位的数字循环周期会短，所以只输出低位可以更好的通过统计学测试。</p>
<p>以上这个算法从1960年代用到现在，那足见其优越性。但它必然也有些缺点。一个是你的a,b,c三个参数必须小心选择，选的不好，就会出问题。一个著名例子是，1960年代IBM所使用的一个LCG算法叫RANDU，它是用$latex 65539\times x\bmod 2^{31}$，听上去这几个数字没啥特别不好，输出看上去也很正常。但是1963年，有人发现通过简单运算，发现它连续迭代的三项余数之间是有一个简单的减法关系，就是当前项与之前的两项有个线性关系。这使得这个算法在统计学上是完全失败了。虽然IBM在后来的机器中修正了参数，但是很多人要么不知情，要么不在意，继续使用这一算法。因为以前没网络，软件打补丁也很麻烦嘛。后果就是70年代里很多使用这个算法产生的研究结果都被认为不可靠的。据推测RANDU算法要到90年代早期才真正被废弃。这个RANDU算法就是历史上著名的一个貌似产生随机数，其实很不靠谱的典型例子。这也告诉我们一个随机数算法能不能用，不是靠眼睛看看就可以过关的，你需要很专业的软件对其测试。</p>
<p>另外要注意，在需要严格加密的场合是不能使用LCG算法的，因为如果有人愿意，他是可以从你历史输出里去反算你的种子数的。这相当于一个算术题就是：已知a, b, c和ax+b除以c的余数，请你算一下x。你是可以写一个多项式时间算法的去求解这个问题的。所以你不能使用LCG算法在需要加密的场合，而是要使用后面会提到的所谓“密码学安全”算法。</p>
<p>我们还是再简单说一个LCG算法之后的发展。在1997年，两位日本研究者发明了一个名为“梅森旋转算法”的随机数生成方法。这里的“梅森”，是取自梅森素数（如果$2^{n}-1$是一个素数，它就被称为梅森素数）的意思，因为它的周期就是一个很大的梅森素数。大老李在很早的节目里就介绍过梅森素数，它号称“数字中的宝石”。你看它现在不但是宝石而且还有了实用价值。这个算法比LCG算法的优点在于周期非常长，就是一个大的梅森素数。统计学指标上质量比LCG更优。所以它现在被广泛用语主流的一些操作系统和编程语言，包括Excel，GNU库，php, python和Ruby等等。但同样注意它是密码学不安全的，只要有人拿到足够的输出，还是可以计算出你所使用的种子数的。</p>
<p>再说说所谓“密码学安全”的随机数生成算法。首先我们得给“密码学安全”一个定义，什么叫“密码学安全”。我们看到前面的算法“不安全”，其不安全就在于我们可以通过观察历史数据，来推测出你所使用的种子数，最终达到预测之后所产生的随机数的效果。那反过来也就是，一个密码学安全的随机数算法，要做到我给你相当长的历史数据，你也有非常强的电脑，我仍然可以确保你不能在充分长的时间，比如1年内，对我将来的产生的随机数的猜测，产生任何“不可忽略”的变化。这里的“相当长”，“非常强”，“充分长”，“不可忽略”，都是一些变量，我们不需要对这些变量有精确的数字定义，只要知道这些变量是可以用来衡量最终算法质量的。在不同场合，我们可以给这些变量定义一些值，如果算法能达到我们定义的这些值，那么这么算法就可以被用在我们的这个场合下。</p>
<p>而数学家用的一个高招就是把破解算法的难度与破解一个数学难题等价起来。也就是如果你能破解这个算法，就等于你破解了一个数学上非常难的问题。那你能破解这个数学问题，你就能拿菲尔兹奖，你也犯不着去破解算法吧。当然，也可能有人能破解这些算法了，但是他秘而不宣，利用这能力谋取利益，或者达到一些自己的目的。比如《达芬奇密码》这部小说的作者丹布朗的另一部小说《数字城堡》，其背景就是说美国政府秘密造出一台超级计算机和一个秘密算法，使得他们可以解密目前网上主流加密算法加密过的信息，这样美国政府就可以监控很多网上的秘密通信了。当然，这只是小说的设定，目前没有什么证据能证明有人掌握了某种超级解密算法。</p>
<p><img class=" size-full wp-image-986 aligncenter" src="https://dalaoliblog.files.wordpress.com/2018/07/digital_fortress.jpg" alt="digital_fortress.jpg" width="187" height="269" /></p>
<p style="text-align:center;">（上图：丹布朗的小说《数字城堡》封面）</p>
<p>密码学安全算法我就不一一列举了，只说其中有一个，有一个以三个发明者名字首字母命名的B.B.S.算法。这个算法的安全性就是依靠数学中的所谓“二次剩余”问题：就是求x^2除某个数，在B.B.S算法中这个数是两个大素数相乘，求余数。你计算x^2除一个大数的余数很简单，但是它的逆运算，就是你需要找到一个完全平方数，使得它除以某个很大的数正好是某个余数，就难很多了。算法还有些其他细节，但总体上就是依靠了二次剩余问题的难度来确保了算法安全性。</p>
<p>密码学安全算法虽然“安全”，但你完全不必要在任何场合都是用这类算法，因为它们要比前面的LCG和梅森旋转慢许多，而且消耗更多内存资源。所以你一般应用中完全不需要用“密码学安全”算法。另外，当你需要密码学安全算法时，也需要很小心的挑选。有一个让人浮想联翩的新闻是2013年，有人发表了篇博客，指出美国国家安全局NSA推荐的一个“密码学安全”随机数算法中（ <a href="https://en.wikipedia.org/wiki/Dual_EC_DRBG">Dual_EC_DRBG</a>），所使用的参数是有弱点的，这就是一个后门！也就是这个算法本身没问题，但是NSA推荐的初始化参数是精心挑选过的，使得这个算法有了弱点，是有可能被推算出随机数。你如果用了NSA推荐的这些参数，那你的随机数就可能被美国国家安全局破解。这篇博客至今网上还能看到，我也没有看到NSA有任何回应，也没法回应了。这真的像小说情节，但现实中就发生了。</p>
<p>好了以上说了那么多算法，其实还漏了一个随机数算法中的要点，就是这个“种子”数的产生。前面说过了这个种子数决定了算法从其周期哪个位置开始产生随机序列。如果算法两次输出的种子数一样，或者太接近，那么你的输出立即或很快就发生重复了，这是我们不希望的。所以我们需要一个随机数来"启动"一个随机数算法，这就是种子。但这个种子就不能依靠算法来产生了，否则这就是死循环了。</p>
<p>前面说过可以用系统时间的毫秒数作为种子数，但有些场合，这还不够随机，你还是嫌重复几率太大。那就需要搜集计算机能搜集到的像“随机”情况的数值，或者叫“熵”。常见的方法有让用户随便敲几下键盘，移动几下鼠标，检测一下最近两次敲键的时间间隔，鼠标移动距离，CPU的温度，声卡传进来的噪音，如果是手机话还可以检查手机摆放的角度等等。总之，采集各种可以采集到的噪音数据，然后用算法混合起来，以便使整个种子数看上去最为“随机”，最难预测。</p>
<p>还有的软件为了安全性，规定产生若干个随机数后要重新产生一个种子，就是重置一次。像Linux操作系统就自带了两个随机数生成器(/dev/random, /dev/urandom)，其中一个(/dev/random)就需要不断重置种子，如果它搜集到的噪声不够多，它就会停下来，受到阻塞，直到搜集到足够多的噪声也就是熵之后才能继续。幸好，绝大多数场合下另一个不会阻塞的随机生成器已经是足够好用了。</p>
<p>最后，向大家介绍一个看上有点夸张，但确实在实际在使用的一个种子随机数生成器，叫“岩浆灯”，Lava Lamp。这种岩浆灯确实像一盏灯，也有点像沙漏，但里面并不是放岩浆，而是两种不同颜色的液体，这两种液体的比重差不多，但不会互相溶解。所以你就会看到这种岩浆灯里面的液体就不停的发生变动，比如一种颜色液体翻滚到上面，或者分裂成2团，或者又沉下去。这种变化看上去是完全随机的，物理老师会告诉我们这叫“布朗运动”。我也在节目介绍里放了一张这样的“岩浆灯“图片。</p>
<p><img class=" size-full wp-image-987 aligncenter" src="https://dalaoliblog.files.wordpress.com/2018/07/lava_lamp.jpg" alt="lava_lamp.jpg" width="275" height="183" /></p>
<p>这种岩浆灯最早是1990年代，SGI公司发明的，就是发布OpenGL这个图形软件库的厂商，他们还给注册了专利。1997到2001有家公司短暂用了这种岩浆灯，但商业化不成功，很快放弃。但后来2009年成立的，位于旧金山的一家叫Cloundflare的公司重新使用了这种岩浆灯。他们的业务中有重要的一块就是向客户提供网站需要的SSL证书。现在我们访问网站时，浏览器会时常提醒你这个网站有问题，证书不被信任等等，其实就是SSL证书在起作用。而要生成SSL证书，就需要产生随机数，要产生随机数，就要种子，他们就用岩浆灯来生成种子随机数。</p>
<p>他们还不是使用一盏岩浆灯，而是用数十盏岩浆灯，铺满一堵墙，然后用一个摄像头不断的去拍摄这面墙，因为岩浆灯不停的在变化，所以摄像头拍到的画面肯定也是不停的在变化，再加上摄像头拍摄也有噪点，温度湿度变化也对拍摄有影响等等，这些噪声结合在一起，那摄像头拍出的这幅画面用二进制来看确实是无法预测了。而且他们还在世界各地三个办公室都设置了这种岩浆灯，要三个办公室产生的随机数结合在一起混淆后才作为最后所使用的种子数。</p>
<p>听上去是不是为了一个产生随机数如此兴师动众是不是有点夸张，但这种岩浆灯确确实实在提供服务，而且估算现在互联网上10%的流量都是使用他们公司产生的SSL证书。不过我时常在想有必要这么兴师动众吗，干嘛不用中国很多地铁站的监控摄像头的图像，好像也一样效果：）</p>
<p>好了，有关软件随机数生成算法就到这里了，我最大感想是，生成安全可靠的随机数出人意料的难，而且到了几乎无所不用其极的地步。</p>
<p>有些听众也可能在想有没有硬件随机数生成器呢？当然有啊，比如福利彩票开奖用的那个吹乒乓球的机器，就是一个硬件随机数生成器啊。前面的岩浆灯也是，如果我们将来的电脑能内置一个丢硬币的装置，那也是一个硬件随机数生成器，开个玩笑了。但历史上确实有各种电脑上可以用的硬件随机数生成器，硬件的优越性就在于可以更多搜集环境噪音。</p>
<p><img class=" size-full wp-image-988 aligncenter" src="https://dalaoliblog.files.wordpress.com/2018/07/fulicaipiao.jpg" alt="fulicaipiao" width="300" height="168" /></p>
<p>目前有人在考虑就是使用量子的随机属性来产生随机数，比如电路的瞬间噪声，粒子的衰变时间，光子穿过半透玻璃的概率等等。这些量子行为是目前人类认为最为接近“真”随机的自然现象了。如果能有使用量子的随机性产生的随机数，那应该是最为安全和最为接近”真”随机数的随机数。</p>
<p>好了，有关随机数就聊到这里，我们下期再见！</p>
<hr />
<p><strong>大老李聊数学”第二季已开播！</strong>识别如下二维码即可：</p>
<p><img class="alignnone size-full wp-image-898" src="https://dalaoliblog.files.wordpress.com/2018/05/ximalaya_season1.png?w=1108" alt="ximalaya_season1.png" /></p>
<hr />
<p>关注“大老李聊数学”公众号，微信搜搜：dalaoli_shuxue</p>
<p>&nbsp;</p>
</div><p><a href="/2018/07/14/e9-9a-8f-e6-9c-ba-e4-b8-8d-e6-98-af-e8-83-a1-e6-9d-a5-ef-bc-882-ef-bc-89-e9-9a-8f-e6-9c-ba-e6-95-b0-e7-9a-84-e7-94-9f-e6-88-90-ef-bc-88-e8-ae-b2-e7-a8-bf.html">阅读更多</a></p></div><div class="article__info clearfix"><ul class="right-col menu"><li><i class="fas fa-user"></i> <span>大老李</span></li><li><i class="far fa-calendar-alt"></i> <span>2018年 07月14日</span>
            </li></ul></div><meta itemprop="author" content="大老李"/><meta itemprop="datePublished" content="2018-07-14T09:34:13+00:00"></div>
      </article><article class="item" itemscope itemtype="http://schema.org/BlogPosting"><div class="item__content">
          <header><h2 itemprop="headline" class="item__header"><a href="/2018/07/09/e9-9a-8f-e6-9c-ba-e4-b8-8d-e6-98-af-e8-83-a1-e6-9d-a5-ef-bc-881-ef-bc-89-e9-9a-8f-e6-9c-ba-e6-95-b0-e7-9a-84-e6-a3-80-e9-aa-8c.html">“随机”不是“胡来”（1）--随机数的检验</a></h2></header>
          <div class="item__description"><div class="article__content" itemprop="description articleBody"><p>大家好，我是大老李。这期节目准备跟大家聊聊随机数。这个话题来自一位听众，想让我聊聊计算机是如何生成随机数的。我搜了一些资料，发现这是一个很有深度的话题，有关随机数有很多意向不到的陷阱和反直觉的一些事情。而我发现，从检验随机数这个话题开始，可以帮助大家更好理解，等下期我们再聊怎么生成随机数。</p>
<p>要说怎么检验随机数，我们还是考虑一个最简单的例子，如果我想让你生成一串0和1的数字序列，而且符合所谓0-1二项分布，0和1的概率各50%，你会怎么做？当然，这很简单，你可以拿一枚硬币不停的丢，看到正面写个0，背面写个1。当然，也会有偷懒的朋友会说，我直接瞎写就可以了，只要我0和1写的总数差不多就可以了。现在问题是，如果我给你两个0-1的序列，其中一个是某人用丢硬币的方法产生的，另一个是某人“随便”手写产生的，请问你有办法鉴别出来这两个序列哪个是丢硬币产生的，哪个是“手写”产生的？</p>
<p>其实稍微思考下，你就会发现，只要你给我的两个序列足够长，我就能鉴别出来。因为随机数是有特征的，我们课堂上都学过，比如期望值，方差，等等。那对这个0-1的序列，我当然会先考察下0和1的数量是不是差不多。就算你手写的时候非常小心，把0和1写的很均匀，那还有好多其他特征可以考察。</p>
<p>这个例子里，如果0和1的数量符合期望了，那方差也是没问题的。但我们可以考虑比如其中的最长的连续的1的序列，就是连着出现多个1的情况。如果10000个0-1的随机序列，里面连续最长的1的长度只有4，那我凭直觉也知道这个序列是有问题了。虽然从某个特定位置开始连续出现5个1的概率是1/32，但是在1万个数字里一次也没发生的概率，我粗糙算下大约只有10^(-35)这个数量级（大老李的“糙算”，如有准确算法，也请告知）。事实，在长度1万的0-1随机序列里，最长的连续1的长度，大致是在9到15之间。</p>
<p>以上例子就是说明，用“瞎写”的方式产生的随机数，并不是“真正”的随机数，有很多方法可以鉴别出这种假随机数。那我们为什么需要检验随机数呢？这可太重要了，小到一个游戏程序，大到一次彩票开奖，或者信息的加密传输，这些都需要随机数。如果你的随机数不够“随机”，那就会让人有机可乘，这个后果可大可小，但对银行，军事部门来说，他们对随机数的要求肯定是非常高的。</p>
<p>那又有一个问题，究竟什么是真正的“随机”？很意外，这是一个非常微妙甚至哲学化的问题。比如丢硬币产生的序列算不算随机呢？看上去是随机的，但是正如很多文章里说的，如果硬币丢出去以后，如果所有的物理参数我都知道了，比如初速度，角度，空气阻力，湿度，硬币密度，形状等等所有与硬币落下后相关的参数都已知，并且我有一个计算速度极快的计算机，那我就可以计算出硬币落下后“将“会正面还是背面，那丢硬币结果还算不算随机数的？爱因斯坦甚至有句名言叫“上帝不掷骰子”。今天我们不能扯远去聊物理相关话题，我只是什么是真正的随机数，自然界中有没有随机现象至今还是一个有争议也十分微妙的问题。</p>
<p>但数学里，特别是密码学里，还是给“真”随机数给出了一个定义，比如”真正”的符合1/2对1/2概率的0-1二项分布的随机变量定义就是这样：设想一个游戏，我是给出0-1分布随机数的，你是猜随机数的。我每次会产生一个0或1的随机数，你要去猜。你有几个便利条件，我允许你在猜之前向我要任意多的数量的随机数。也就是说，你可以研究过往随机数的历史，如果你认为这对下一次猜测有用的话。而且你想要多少我就给你多少，这是一个便利条件。另一个便利条件是你有一个无限计算能力的计算机，要多块就多块，也就是你可以尽情的在猜之前利用这台机器机去分析，甚至于我可以先产生一个新的随机数，但不给你去看，你还是尽可以去算。等你觉得算够的时候，你就可以猜0或是1。而所谓“真”随机数就是，这个游戏经过非常多次之后，你能猜对的概率仍然是½，那么我产生的随机数就是所谓“真”0-1二项均匀分布。</p>
<p>如果最后这句话你认为还不够精确的话，我可以用数学语言重新叙述下就是：对任意小的ε，存在一个Δ，当游戏次数进行大于等于Δ次之后，你猜中的次数除以游戏总次数的比值-1/2的绝对值，总会小于ε。好了，以上就是完美随机数的定义，是不是出奇的啰嗦，但是以上条件缺一不可。首先，我得允许你看历史随机数，真正的随机数是与历史无关的，所以你如果能通过学习历史哪怕使你的猜测的成功率增加0.00001，那这个随机数就是失败的。而且我得允许你有无限计算能力的计算机，你不能因为是别人计算速度不够导致猜不准，理由跟之前一样，就是随机数就是独立事件，与之前的结果无关。最后要注意的是，你猜测的结果最后与0.5比较是要取绝对值的，就是你猜对或者猜错的“能力”都要能“收敛”在0.5上。如果你有了大于0.5几率的“猜错”能力，那等价于你有了“猜对”的能力，这也是不行的。</p>
<p>以上我们虽然有了完美随机数的定义，但实践中这个定义却没有什么用，因为以上这个游戏纯属理想试验，我没法保证在我人生有限时间里给你任意长度的随机数，你也根本没有任意算力的计算机。所以我们产生随机数，特别是用软件产生的随机数，只能尽量去接近这个标准，而无法达到这一标准。下一期会具体讲讲计算机产生随机数的方法。</p>
<p>今天还是先说说随机数的检验，这里说的随机数的检验主要是对计算机随机数生成算法的检验。以下我们从最简单的测试开始：</p>
<p>第一级测试就是：范围测试，就是测试你的产生的随机数是不是都位于目标范围。这个测试意义比较简单，如果你的随机数的范围是0到1之间，那么我测试发现你产生了小于0或者大于1的随机数，那肯定是你的算法有问题了。但是边界上还是需要注意。比如你的算法是期望产生大于0小于等于1的范围，但是实际算法不能产生1，或者会产生0，但是概率都很小，那么测试软件就可能发现不了这些问题。这种问题是很难通过软件发现的，只能靠人为去分析算法来验证。</p>
<p>第二级测试就是均值测试，就是看期望值。比如你的随机数如果期望值是100，那我就跑1万个随机值出来，求个平均值，看看是不是够接近100。另外学过概率的人应该知道“置信空间”这个概念，也就是我可以计算出我这一万个随机数平均值有比如95%的概率应该是在怎样的区间内，比如是100+-5的范围，如果算出来平均值是106，那我就有95%的把握说你的算法是有问题的。</p>
<p>第三级测试就是所谓方差测试，就是看变量的变化程度。前面说了均值测试，如果我的均值的期望值是100，然后我发现每次测试一万个随机数的平均值，都是恰好100，不多不少。如果1次这样我还信，给我来10次都正好100，那无论如何我都不信这是随机数序列！这里再一次有所谓置信空间，我可以知道随机数的变化分布程度是否在我预设的置信空间内。</p>
<p>以上我们测试里随机变量的均值和方差，这是随机变量的两个基本特征。但即使符合这两个特征了，也不表示你的算法就是对的。比如对期望值是1的指数分布，和期望值是1且方差也是1的正态分布，这两种分布的期望值和方差都是1。如果你不小心在应该产生正态分布随机数的代码里，用了产生指数分布的算法，那用以上两种测试就测不出区别了。这是就需要第三级测试，叫“分桶”测试(Bucket Test)，水“桶”的桶。这也好理解，概率教科书里都给我们画过每种概率分布的概率密度函数，正态分布是所谓像一口倒扣的钟的形状的“钟形曲线”，指数分布是从左上到右下下降的曲线。要区分这两种情况，我就可以把在x坐标轴上等距离取若干个点，然后画垂线，每两条垂线之间就是一个个“桶”，然后考察随机变量落到不同的桶中的数量。比如对正态分布，我知道在期望值两边对称的桶里的变量数量应该是差不多多的，但是对于指数分布，左边的桶就要比右边的桶里的变量数量要多。这样，我就能区分出两种分布。</p>
<p>桶测试已经是非常细致的测试了，但是桶测试的精度跟桶划分的密度有关，不管怎么划分，你也只能划分有限多个桶，你还是有小概率使得你的算法在某个桶内的狭小范围内失真。所以，这里有个终极测试叫柯尔莫哥罗夫-斯米尔诺夫检验（Kolmogorov-Smirnov test），简称KS测试。一听这个名字你就知道这都是俄罗斯的数学家。这个测试的基本理念就是画出（准确来讲是拟合）测试样本的概率累积函数图像，然后与理论上的经验累积函数图像比较。有时是取两组测试样本画出两条概率累积函数图像互相比较。这个概率累积函数大家课本上也应该讲过，就是函数值从0变化到1的一条曲线，其实就是概率密度函数的积分函数图像。先不管这具体函数定义，但可以想象如果算法是对的，那我的样本你拟合出来的累积函数图像应该是比较接近经验概率累积函数图像的，虽然总有些误差。这个KS测试就是取你的实验结果的函数图像与理论图像在某个垂直线上的最大差值。如果这个差值大到我们事先设定的某个“阈值”，或者说这个差值足够“显著”，那我们就要考虑我们的随机数算法就是有问题了。当然，虽然我说的如此简单，但是实际这个这个测试是有相当复杂数学依据的，也就是这个检验可以定量的告诉你这个最大误差K发生的概率是多少，或者在一定执行空间内， 这个误差应该在什么范围。</p>
<p>[gallery ids="981,982" type="rectangular"]</p>
<p>（左图：红线为理论概率分布函数，蓝色为实验数据。右图：红和蓝线都是实验数据。黑色箭头为两条曲线垂直方向上最大差值，即为判断数据是否符合概率分布的依据，称为KS统计值）</p>
<p>这个KS测试已经是相当优秀的，它也有一些变体测试，比如Shapiro–Wilk test or Anderson–Darling test.，每种测试都各有利弊，这里大老李就没法一一细数了。</p>
<p>关于随机数的测试，基本就是以上这些了，下一期大老李会具体讲讲计算机是怎么产生随机数的。有意思的是能够通过以上这些测试的随机数算法，并不一定是“安全”的算法，也就是没法用在需要严格加密领域的随机数生成。而有些被证明是非常安全的随机数算法，并不能保证每次都能通过以上测试，尤其是桶测试和KS测试。这也是可以理解，因为随机数本就是随机嘛，如果它的行为100%的能通过测试，那它也不随机了。这就是随机数的微妙和有趣之处。好，我们下期再见。</p>
<hr />
<p><strong>大老李聊数学”第二季已开播！</strong>识别如下二维码即可：</p>
<p><img class="alignnone size-full wp-image-898" src="https://dalaoliblog.files.wordpress.com/2018/05/ximalaya_season1.png?w=1108" alt="ximalaya_season1.png" /></p>
<hr />
<p>关注“大老李聊数学”公众号，微信搜搜：dalaoli_shuxue</p>
<p>&nbsp;</p>
</div><p><a href="/2018/07/09/e9-9a-8f-e6-9c-ba-e4-b8-8d-e6-98-af-e8-83-a1-e6-9d-a5-ef-bc-881-ef-bc-89-e9-9a-8f-e6-9c-ba-e6-95-b0-e7-9a-84-e6-a3-80-e9-aa-8c.html">阅读更多</a></p></div><div class="article__info clearfix"><ul class="right-col menu"><li><i class="fas fa-user"></i> <span>大老李</span></li><li><i class="far fa-calendar-alt"></i> <span>2018年 07月09日</span>
            </li></ul></div><meta itemprop="author" content="大老李"/><meta itemprop="datePublished" content="2018-07-09T06:50:56+00:00"></div>
      </article><article class="item" itemscope itemtype="http://schema.org/BlogPosting"><div class="item__content">
          <header><h2 itemprop="headline" class="item__header"><a href="/2018/07/09/e6-af-8f-e5-91-a8-e4-b8-80-e9-a2-98-ef-bc-9a-e4-b8-96-e7-95-8c-e6-9d-af-e4-b8-ad-e7-90-83-e9-98-9f-e8-b8-a2-e4-b8-a4-e6-ac-a1-e7-9a-84-e6-a6-82-e7-8e-87-ef-bc-88-e9-99-84-e4-b8-8a-e6-9c-9f-e7-ad-94.html">每周一题：世界杯中球队踢两次的概率（附上期答案）</a></h2></header>
          <div class="item__description"><div class="article__content" itemprop="description articleBody"><h1>本期题目：世界杯中球队踢两次的概率（附上周答案）</h1>
<p>（题目来源：fivethirtyeight.com）</p>
<p><img class=" size-full wp-image-978 aligncenter" src="https://dalaoliblog.files.wordpress.com/2018/07/wolrd_cup.jpg" alt="wolrd_cup.jpg" width="275" height="183" /></p>
<p>世界杯如火如荼进行中，请你考虑一个世界杯中的概率题：在一届世界杯32支球队中，出现（至少一次）两支球队互相遭遇两次的概率是多少？</p>
<p>注：世界杯中两支球队遭遇两次的唯一情况是，一次在小组赛中相遇，一次在决赛或者三四名比赛中相遇。同时我们假设每一支球队的水平或赢球概率是一样的。</p>
<p>本届世界杯中，同一小组出现的英格兰和比利时都还在，他们有可能在3，4名比赛中遭遇。</p>
<p>请直接留言作答。</p>
<hr />
<h1>上期答案：</h1>
<p>上周题目是：</p>
<blockquote><p>上周张三想在机场简短锻炼下身体，他选择了一条自动步道机（机场常见的类似自动扶梯或传送带的装置，设置于地面用于加速行走的），在上面<strong>逆向</strong>行走了100米时，张三不慎将登机牌掉落在步道机上，张三并未意识到。张三又走了90秒后，发现遗失了登机牌，急忙回转去寻找登机牌。此时他是顺向在步道机上行走，且速度是之前的2倍。终于，他在登机牌距离步道机起点只有10米时找到了登机牌。问步道机的移动速度是多少？</p></blockquote>
<p>答案是：答案是<strong>2/3米每秒</strong>。</p>
<p>假设张三行走的速度是v，则张三发现登机牌丢失开始往回走时，钱包距离他90*v。因为他追钱包时，行走速度是2v，则他应该花了90/2=45秒追到钱包。所以在总共90+45秒时间里，钱包相对地面移动了100-10=90米。所以步道机速度为90/(90+45)=2/3米每秒。</p>
<p>恭喜：<strong>姜文赟，半缘君，高兴就好，Lian，韩w，Stones，黄亮</strong>答对了！</p>
<p>&nbsp;</p>
<hr />
<p><strong>大老李聊数学”第二季已开播！</strong>识别如下二维码即可：</p>
<p><img class="alignnone size-full wp-image-898" src="https://dalaoliblog.files.wordpress.com/2018/05/ximalaya_season1.png" alt="ximalaya_season1.png" width="426" height="418" /></p>
<p>下周再见！</p>
<hr />
<p>关注“大老李聊数学”公众号，微信搜索： dalaoli_shuxue</p>
<p>&nbsp;</p>
</div><p><a href="/2018/07/09/e6-af-8f-e5-91-a8-e4-b8-80-e9-a2-98-ef-bc-9a-e4-b8-96-e7-95-8c-e6-9d-af-e4-b8-ad-e7-90-83-e9-98-9f-e8-b8-a2-e4-b8-a4-e6-ac-a1-e7-9a-84-e6-a6-82-e7-8e-87-ef-bc-88-e9-99-84-e4-b8-8a-e6-9c-9f-e7-ad-94.html">阅读更多</a></p></div><div class="article__info clearfix"><ul class="right-col menu"><li><i class="fas fa-user"></i> <span>大老李</span></li><li><i class="far fa-calendar-alt"></i> <span>2018年 07月09日</span>
            </li></ul></div><meta itemprop="author" content="大老李"/><meta itemprop="datePublished" content="2018-07-09T06:18:57+00:00"></div>
      </article></div><div class="pagination"><p>共计 76 篇文章，10 页。</p>
    <div class="pagination__menu">
      <ul class="menu menu--nowrap"><li><a class="button button--secondary button--circle" href="/">
            <i class="fas fa-angle-left"></i>
          </a></li><li>
              <a class="button button--secondary button--circle" href="/"><span>1</span></a>
            </li><li>
              <div class="button button--primary button--circle focus"><span>2</span></div>
            </li><li>
                  <a class="button button--secondary button--circle" href="/page3"><span>3</span></a>
                </li><li>
                  <a class="button button--secondary button--circle" href="/page4"><span>4</span></a>
                </li><li><span class="pagination__omit"><i class="fas fa-ellipsis-h"></i></span></li><li>
                  <a class="button button--secondary button--circle" href="/page10"><span>10</span></a>
                </li><li><a class="button button--secondary button--circle" href="/page3">
            <i class="fas fa-angle-right"></i>
          </a></li></ul>
    </div>
  </div></div>
<script>/*(function () {

})();*/</script>

</div></article>
            </div>
          </div></div></div>

      <div class="page__footer">
<div class="footer js-page-footer">
  <div class="main"><aside  itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大老李"><meta itemprop="url" content="https://dalaoli-shuxue.github.io/"><meta itemprop="description" content="爱数学的IT男，兼摇滚中年。"><div class="footer__author-links"><div class="author-links">
  <ul class="menu menu--nowrap menu--inline"><link itemprop="url" href="https://dalaoli-shuxue.github.io/"><li title="给我发邮件。">
      <a class="button button--circle mail-button" itemprop="email" href="mailto:liyouhua@gmail.com" target="_blank">
        <i class="fas fa-envelope"></i>
      </a></ul>
</div>
</div>
    </aside>
    <footer class="site-info"><p class="menu menu--center">
        <span>© 大老李聊数学 2018</span>
        <a type="application/rss+xml" href="/feed.xml">RSS</a>
      </p>
      <p>Powered by <a title="Jekyll is a simple, blog-aware, static site generator." href="http://jekyllrb.com/">Jekyll</a> & <a
        title="TeXt is a succinct theme for blogging." href="https://github.com/kitian616/jekyll-TeXt-theme">TeXt Theme</a>.
      </p>
    </footer>
  </div>
</div></div>
    </div>
  </div><div class="page__search-panel"><div class="search">
  <div class="main">
    <div class="search__header">搜索</div>
    <div class="search-bar">
      <div class="search-box js-search-box">
        <div class="search-box__icon-search"><i class="fas fa-search"></i></div>
        <input type="text" />
        <div class="search-box__icon-clear js-icon-clear">
          <a><i class="fas fa-times"></i></a>
        </div>
      </div>
      <button class="button button--secondary button--pill search__cancel js-search-toggle">
        取消</button>
    </div>
    <div class="search-result js-search-result"></div>
  </div>
</div>

<script>var SOURCES = window.TEXT_VARIABLES.sources;
var PAHTS = window.TEXT_VARIABLES.paths;
window.Lazyload.js([SOURCES.jquery, PAHTS.search_js], function() {
  var searchData = window.TEXT_SEARCH_DATA ? initData(window.TEXT_SEARCH_DATA) : {};

  function memorize(f) {
    var cache = {};
    return function () {
      var key = Array.prototype.join.call(arguments, ',');
      if (key in cache) return cache[key];
      else return cache[key] = f.apply(this, arguments);
    };
  }

  function initData(data) {
    var _data = [], i, j, key, keys, cur;
    keys = Object.keys(data);
    for (i = 0; i < keys.length; i++) {
      key = keys[i], _data[key] = [];
      for (j = 0; j < data[key].length; j++) {
        cur = data[key][j];
        cur.title = window.decodeUrl(cur.title);
        cur.url = window.decodeUrl(cur.url);
        _data[key].push(cur);
      }
    }
    return _data;
  }

  /// search
  function searchByQuery(query) {
    var i, j, key, keys, cur, _title, result = {};
    keys = Object.keys(searchData);
    for (i = 0; i < keys.length; i++) {
      key = keys[i];
      for (j = 0; j < searchData[key].length; j++) {
        cur = searchData[key][j], _title = cur.title;
        if ((result[key] === undefined || result[key] && result[key].length < 4 )
          && _title.toLowerCase().indexOf(query.toLowerCase()) >= 0) {
          if (result[key] === undefined) {
            result[key] = [];
          }
          result[key].push(cur);
        }
      }
    }
    return result;
  }

  var renderHeader = memorize(function(header) {
    return $('<p class="search-result__header">' + header + '</p>');
  });

  var renderItem = function(index, title, url) {
    return $('<li class="search-result__item" data-index="' + index + '"><a class="button" href="' + url + '">' + title + '</a></li>');
  };

  function render(data) {
    if (!data) {
      return null;
    }
    var $root = $('<ul></ul>'), i, j, key, keys, cur, itemIndex = 0;
    keys = Object.keys(data);
    for (i = 0; i < keys.length; i++) {
      key = keys[i];
      $root.append(renderHeader(key));
      for (j = 0; j < data[key].length; j++) {
        cur = data[key][j];
        $root.append(renderItem(itemIndex++, cur.title, cur.url));
      }
    }
    return $root;
  }

  // search box
  var $searchBox = $('.js-search-box');
  var $searchInput = $searchBox.children('input');
  var $searchClear = $searchBox.children('.js-icon-clear');
  var $result = $('.js-search-result'), $resultItems;
  var lastActiveIndex, activeIndex;

  function searchBoxEmpty() {
    $searchBox.removeClass('not-empty'); $result.html(null);
    $resultItems = $('.search-result__item'); activeIndex = 0;
  }

  $searchInput.on('input', window.throttle(function() {
    var val = $(this).val();
    if (val === '' || typeof val !== 'string') {
      searchBoxEmpty();
    } else {
      $searchBox.addClass('not-empty'); $result.html(render(searchByQuery(val)));
      $resultItems = $('.search-result__item'); activeIndex = 0;
      $resultItems.eq(0).addClass('active');
    }
  }, 400));
  $searchInput.on('focus', function() {
    $(this).addClass('focus');
  });
  $searchInput.on('blur', function() {
    $(this).removeClass('focus');
  });
  $searchClear.on('click', function() {
    $searchInput.val(''); searchBoxEmpty();
  });

  // search panel
  var $pageRoot = $('.js-page-root');
  var $searchToggle = $('.js-search-toggle');
  var showSearch = false;

  function closeSearchPanel() {
    $pageRoot.removeClass('show-search-panel');
    $searchInput[0].blur();
    setTimeout(function() {
      $searchInput.val(''); searchBoxEmpty();
      window.pageAsideAffix && window.pageAsideAffix.refresh();
    }, 400);
  }
  function openSearchPanel() {
    $pageRoot.addClass('show-search-panel');
    $searchInput[0].focus();
  }

  // Char Code: 13  Enter, 27  ESC, 37  ⬅, 38  ⬆, 39  ➡, 40  ⬇, 83  S, 191 /
  function isFormElement(e) {
    var tagName = e.target.tagName || e.srcElement.tagName;
    return tagName === 'INPUT' || tagName === 'SELECT' || tagName === 'TEXTAREA';
  }
  function charCodeFilter(e) {
    return e.target === $searchInput[0] && (e.which === 13 || e.which === 27 || e.which === 38 || e.which === 40);
  }

  function updateResultItems() {
    lastActiveIndex >= 0 && $resultItems.eq(lastActiveIndex).removeClass('active');
    activeIndex >= 0 && $resultItems.eq(activeIndex).addClass('active');
  }

  function moveActiveIndex(direction) {
    var itemsCount = $resultItems ? $resultItems.length : 0;
    if (itemsCount > 1) {
      lastActiveIndex = activeIndex;
      if (direction === 'up') {
        activeIndex = (activeIndex - 1 + itemsCount) % itemsCount;
      } else if (direction === 'down') {
        activeIndex = (activeIndex + 1 + itemsCount) % itemsCount;
      }
      updateResultItems();
    }
  }

  $(document).on('keyup', function(e) {
    if (!isFormElement(e) || charCodeFilter(e)) {
      if (e.which === 83 || e.which === 191) {
        showSearch || (showSearch = true, openSearchPanel());
      } else if (e.which ===  27) {
        showSearch && (showSearch = false, closeSearchPanel());
      } else if (e.which === 38) {
        showSearch && moveActiveIndex('up');
      } else if (e.which === 40) {
        showSearch && moveActiveIndex('down');
      } else if (e.which === 13) {
        showSearch && $resultItems && activeIndex >= 0 && $resultItems.eq(activeIndex).children('a')[0].click();
      }
    }
  });

  $result.on('mouseover', '.search-result__item > a', function() {
    var itemIndex = $(this).parent().data('index');
    itemIndex >= 0 && (lastActiveIndex = activeIndex, activeIndex = itemIndex, updateResultItems());
  });

  $searchToggle.on('click', function() {
    showSearch = !showSearch;
    showSearch ? openSearchPanel() : closeSearchPanel();
  });
});</script></div></div>


<script>(function() {
  var SOURCES = window.TEXT_VARIABLES.sources;
  window.Lazyload.js(SOURCES.jquery, function() {
    function scrollToAnchor(anchor, duration, callback) {
      var $root = this;
      $root.animate({ scrollTop: $(anchor).position().top }, duration, function() {
        window.history.replaceState(null, '', window.location.href.split('#')[0] + anchor);
        callback && callback();
      });
    }
    $.fn.scrollToAnchor = scrollToAnchor;
  });
})();(function() {
  var SOURCES = window.TEXT_VARIABLES.sources;
  window.Lazyload.js(SOURCES.jquery, function() {
    var $window = $(window), $root, $scrollTarget, $scroller, $scroll;
    var rootTop, rootLeft, rootHeight, scrollBottom, rootBottomTop;
    var offsetBottom = 0, disabled = false, scrollTarget = window, scroller = 'html, body', scroll = window.document;
    var hasInit = false, isOverallScroller = true, curState;

    function setOptions(options) {
      var _options = options || {};
      _options.offsetBottom && (offsetBottom = _options.offsetBottom);
      _options.scrollTarget && (scrollTarget = _options.scrollTarget);
      _options.scroller && (scroller = _options.scroller);
      _options.scroll && (scroll = _options.scroll);
      _options.disabled !== undefined && (disabled = _options.disabled);
      $scrollTarget = $(scrollTarget);
      $scroller = $(scroller);
      isOverallScroller = window.isOverallScroller($scrollTarget[0]);
      $scroll = $(scroll);
    }
    function initData() {
      top();
      rootHeight = $root.outerHeight();
      rootTop = $root.offset().top + (isOverallScroller ? 0 :  $scrollTarget.scrollTop());
      rootLeft = $root.offset().left;
    }
    function calc(needInitData) {
      needInitData && initData();
      scrollBottom = $scroll.outerHeight() - offsetBottom - rootHeight;
      rootBottomTop = scrollBottom - rootTop;
    }
    function top() {
      if (curState !== 'top') {
        $root.removeClass('fixed').css({
          left: 0,
          top: 0
        });
        curState = 'top';
      }
    }
    function fixed() {
      if (curState !== 'fixed') {
        $root.addClass('fixed').css({
          left: rootLeft + 'px',
          top: 0
        });
        curState = 'fixed';
      }
    }
    function bottom() {
      if (curState !== 'bottom') {
        $root.removeClass('fixed').css({
          left: 0,
          top: rootBottomTop + 'px'
        });
        curState = 'bottom';
      }
    }
    function setState() {
      var scrollTop = $scrollTarget.scrollTop();
      if (scrollTop >= rootTop && scrollTop <= scrollBottom) {
        fixed();
      } else if (scrollTop < rootTop) {
        top();
      } else {
        bottom();
      }
    }
    function init() {
      if(!hasInit) {
        var interval, timeout;
        calc(true); setState();
        // run calc every 100 millisecond
        interval = setInterval(function() {
          calc();
        }, 100);
        timeout = setTimeout(function() {
          clearInterval(interval);
        }, 45000);
        window.pageLoad.then(function() {
          setTimeout(function() {
            clearInterval(interval);
            clearTimeout(timeout);
          }, 3000);
        });
        $scrollTarget.on('scroll', function() {
          disabled || setState();
        });
        $window.on('resize', function() {
          disabled || (calc(true), setState());
        });
        hasInit = true;
      }
    }

    function affix(options) {
      $root = this;
      setOptions(options);
      if (!disabled) {
        init();
      }
      $window.on('resize', window.throttle(function() {
        init();
      }, 200));
      return {
        setOptions: setOptions,
        refresh: function() {
          calc(true); setState();
        }
      };
    }
    $.fn.affix = affix;
  });
})();(function() {
  var SOURCES = window.TEXT_VARIABLES.sources;
  window.Lazyload.js(SOURCES.jquery, function() {
    var $window = $(window), $root, $scrollTarget, $scroller, $tocUl = $('<ul class="toc"></ul>'), $tocLi, $headings, $activeLast, $activeCur;
    var selectors = 'h1,h2,h3', container = 'body', scrollTarget = window, scroller = 'html, body', disabled = false;
    var headingsPos, scrolling = false, rendered = false, hasInit = false;
    function setOptions(options) {
      var _options = options || {};
      _options.selectors && (selectors = _options.selectors);
      _options.container && (container = _options.container);
      _options.scrollTarget && (scrollTarget = _options.scrollTarget);
      _options.scroller && (scroller = _options.scroller);
      _options.disabled !== undefined && (disabled = _options.disabled);
      $headings = $(container).find(selectors);
      $scrollTarget = $(scrollTarget);
      $scroller = $(scroller);
    }
    function calc() {
      headingsPos = [];
      $headings.each(function() {
        headingsPos.push(Math.floor($(this).position().top));
      });
    }
    function setState(element, disabled) {
      var scrollTop = $scrollTarget.scrollTop(), i;
      if (disabled || !headingsPos || headingsPos.length < 1) { return; }
      if (element) {
        $activeCur = element;
      } else {
        for (i = 0; i < headingsPos.length; i++) {
          if (scrollTop >= headingsPos[i]) {
            $activeCur = $tocLi.eq(i);
          } else {
            $activeCur || ($activeCur = $tocLi.eq(i));
            break;
          }
        }
      }
      $activeLast && $activeLast.removeClass('active');
      ($activeLast = $activeCur).addClass('active');
    }
    function render() {
      if(!rendered) {
        $root.append($tocUl);
        $headings.each(function() {
          var $this = $(this);
          $tocUl.append($('<li></li>').addClass('toc-' + $this.prop('tagName').toLowerCase())
            .append($('<a></a>').text($this.text()).attr('href', '#' + $this.prop('id'))));
        });
        $tocLi = $tocUl.children('li');
        $tocUl.on('click', 'a', function(e) {
          e.preventDefault();
          var $this = $(this);
          scrolling = true;
          setState($this.parent());
          $scroller.scrollToAnchor($this.attr('href'), 400, function() {
            scrolling = false;
          });
        });
      }
      rendered = true;
    }
    function init() {
      var interval, timeout;
      if(!hasInit) {
        render(); calc(); setState(null, scrolling);
        // run calc every 100 millisecond
        interval = setInterval(function() {
          calc();
        }, 100);
        timeout = setTimeout(function() {
          clearInterval(interval);
        }, 45000);
        window.pageLoad.then(function() {
          setTimeout(function() {
            clearInterval(interval);
            clearTimeout(timeout);
          }, 3000);
        });
        $scrollTarget.on('scroll', function() {
          disabled || setState(null, scrolling);
        });
        $window.on('resize', window.throttle(function() {
          if (!disabled) {
            render(); calc(); setState(null, scrolling);
          }
        }, 100));
      }
      hasInit = true;
    }
    function toc(options) {
      $root = this;
      setOptions(options);
      if (!disabled) {
        init();
      }
      $window.on('resize', window.throttle(function() {
        init();
      }, 200));
      return {
        setOptions: setOptions
      };
    }
    $.fn.toc = toc;
  });
})();/*(function () {

})();*/</script>
    </div>
    <script>(function () {
  var $root = document.getElementsByClassName('root')[0];
  if (window.hasEvent('touchstart')) {
    $root.dataset.isTouch = true;
    document.addEventListener('touchstart', function(){}, false);
  }
})();</script>
  </body>
</html>